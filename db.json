{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"node_modules/hexo-theme-vivia/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-vivia/source/images/favicon-dark-128.png","path":"images/favicon-dark-128.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-vivia/source/images/favicon-dark-180.png","path":"images/favicon-dark-180.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-vivia/source/images/favicon-dark-192.png","path":"images/favicon-dark-192.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-vivia/source/images/favicon-dark-32.png","path":"images/favicon-dark-32.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-vivia/source/images/favicon-light-128.png","path":"images/favicon-light-128.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-vivia/source/images/favicon-light-180.png","path":"images/favicon-light-180.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-vivia/source/images/favicon-light-192.png","path":"images/favicon-light-192.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-vivia/source/images/favicon-light-32.png","path":"images/favicon-light-32.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-vivia/source/images/tile.png","path":"images/tile.png","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-vivia/source/js/color.global.min.js","path":"js/color.global.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-vivia/source/js/jquery-3.4.1.min.js","path":"js/jquery-3.4.1.min.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-vivia/source/js/light-dark-switch.js","path":"js/light-dark-switch.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-vivia/source/js/load-settings.js","path":"js/load-settings.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-vivia/source/js/script.js","path":"js/script.js","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-vivia/source/css/fonts/FontAwesome.otf","path":"css/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-vivia/source/css/fonts/Roboto-Bold.ttf","path":"css/fonts/Roboto-Bold.ttf","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-vivia/source/css/fonts/Roboto-Medium.ttf","path":"css/fonts/Roboto-Medium.ttf","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-vivia/source/css/fonts/Roboto-Regular.ttf","path":"css/fonts/Roboto-Regular.ttf","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-vivia/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-vivia/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-vivia/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-vivia/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-vivia/source/css/fonts/fontawesome-webfont.woff2","path":"css/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-vivia/source/fontawesome/css/all.css","path":"fontawesome/css/all.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-vivia/source/fontawesome/css/all.min.css","path":"fontawesome/css/all.min.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-vivia/source/fontawesome/css/brands.css","path":"fontawesome/css/brands.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-vivia/source/fontawesome/css/brands.min.css","path":"fontawesome/css/brands.min.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-vivia/source/fontawesome/css/fontawesome.css","path":"fontawesome/css/fontawesome.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-vivia/source/fontawesome/css/fontawesome.min.css","path":"fontawesome/css/fontawesome.min.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-vivia/source/fontawesome/css/regular.css","path":"fontawesome/css/regular.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-vivia/source/fontawesome/css/regular.min.css","path":"fontawesome/css/regular.min.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-vivia/source/fontawesome/css/solid.css","path":"fontawesome/css/solid.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-vivia/source/fontawesome/css/solid.min.css","path":"fontawesome/css/solid.min.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-vivia/source/fontawesome/css/svg-with-js.css","path":"fontawesome/css/svg-with-js.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-vivia/source/fontawesome/css/svg-with-js.min.css","path":"fontawesome/css/svg-with-js.min.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-vivia/source/fontawesome/css/v4-font-face.css","path":"fontawesome/css/v4-font-face.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-vivia/source/fontawesome/css/v4-font-face.min.css","path":"fontawesome/css/v4-font-face.min.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-vivia/source/fontawesome/css/v4-shims.css","path":"fontawesome/css/v4-shims.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-vivia/source/fontawesome/css/v4-shims.min.css","path":"fontawesome/css/v4-shims.min.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-vivia/source/fontawesome/css/v5-font-face.css","path":"fontawesome/css/v5-font-face.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-vivia/source/fontawesome/css/v5-font-face.min.css","path":"fontawesome/css/v5-font-face.min.css","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-vivia/source/fontawesome/webfonts/fa-brands-400.ttf","path":"fontawesome/webfonts/fa-brands-400.ttf","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-vivia/source/fontawesome/webfonts/fa-brands-400.woff2","path":"fontawesome/webfonts/fa-brands-400.woff2","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-vivia/source/fontawesome/webfonts/fa-regular-400.ttf","path":"fontawesome/webfonts/fa-regular-400.ttf","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-vivia/source/fontawesome/webfonts/fa-regular-400.woff2","path":"fontawesome/webfonts/fa-regular-400.woff2","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-vivia/source/fontawesome/webfonts/fa-solid-900.ttf","path":"fontawesome/webfonts/fa-solid-900.ttf","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-vivia/source/fontawesome/webfonts/fa-solid-900.woff2","path":"fontawesome/webfonts/fa-solid-900.woff2","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-vivia/source/fontawesome/webfonts/fa-v4compatibility.ttf","path":"fontawesome/webfonts/fa-v4compatibility.ttf","modified":0,"renderable":1},{"_id":"node_modules/hexo-theme-vivia/source/fontawesome/webfonts/fa-v4compatibility.woff2","path":"fontawesome/webfonts/fa-v4compatibility.woff2","modified":0,"renderable":1},{"_id":"source/assets/bg1.jpg","path":"assets/bg1.jpg","modified":0,"renderable":0},{"_id":"source/assets/head.jpg","path":"assets/head.jpg","modified":0,"renderable":0}],"Cache":[{"_id":"source/_posts/2025-08-01-C610-电调-CAN-通信协议Arduino-Mega2560使用指南.md","hash":"4786bfa8ce5b194c867ae5153afb4658a47ca323","modified":1754036745726},{"_id":"source/about/index.md","hash":"97dcc550adf80c2dd597ab390e01de3aaed14809","modified":1702872756630},{"_id":"source/assets/head.jpg","hash":"8ab556517042c2108ea5bb83c663a16e566fde80","modified":1673610859310},{"_id":"node_modules/hexo-theme-vivia/.gitattributes","hash":"ba3dfe345280bdcc5e817bb02cf49b8b8d8e1c4c","modified":1702872644657},{"_id":"node_modules/hexo-theme-vivia/README.zh-CN.md","hash":"276ec37ef46e782b353e5a953a6c9facd4022eaa","modified":1702872644770},{"_id":"node_modules/hexo-theme-vivia/LICENSE","hash":"1039079fb6969c255e3df9a411ff5f94702f53ad","modified":1702872644658},{"_id":"node_modules/hexo-theme-vivia/README.md","hash":"96ea5f5c9fdd46c24a071c1fc44ab6c338047d89","modified":1702872644770},{"_id":"node_modules/hexo-theme-vivia/package.json","hash":"99c17a9278daba7310d6920960efb70f9e0581df","modified":1702872644769},{"_id":"node_modules/hexo-theme-vivia/example_config.vivia.yml","hash":"92e9b268c3801f8fa97433c462e695a8925f80c1","modified":1702872645171},{"_id":"node_modules/hexo-theme-vivia/_config.yml","hash":"bc429e8233e26aad0b578ec0d5f87bab9156653c","modified":1702872645167},{"_id":"node_modules/hexo-theme-vivia/languages/default.yml","hash":"ea5e6aee4cb14510793ac4593a3bddffe23e530c","modified":1702872645168},{"_id":"node_modules/hexo-theme-vivia/languages/en-US.yml","hash":"ea5e6aee4cb14510793ac4593a3bddffe23e530c","modified":1702872645169},{"_id":"node_modules/hexo-theme-vivia/languages/en-GB.yml","hash":"ea5e6aee4cb14510793ac4593a3bddffe23e530c","modified":1702872645169},{"_id":"node_modules/hexo-theme-vivia/languages/en.yml","hash":"b4b55e56a0554bfdc383650742c2038cef777142","modified":1702872645170},{"_id":"node_modules/hexo-theme-vivia/languages/zh-CN.yml","hash":"89154c7877fa274d340e2adb2241167abda71c60","modified":1702872645172},{"_id":"node_modules/hexo-theme-vivia/languages/zh-TW.yml","hash":"9098818e791e19d9921e256c771664b2cd999e13","modified":1702872645173},{"_id":"node_modules/hexo-theme-vivia/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1702872644720},{"_id":"node_modules/hexo-theme-vivia/languages/zh.yml","hash":"e56bebd19d2abd1698e9aa87d337941957977468","modified":1702872645173},{"_id":"node_modules/hexo-theme-vivia/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1702872644717},{"_id":"node_modules/hexo-theme-vivia/layout/index.ejs","hash":"c9d8dca730a254ab3f48309677a3cb994e513ad6","modified":1702872644726},{"_id":"node_modules/hexo-theme-vivia/layout/layout.ejs","hash":"d28ff99ec0483e5fc0b932ca36afcbf8eeb75dc4","modified":1702872644727},{"_id":"node_modules/hexo-theme-vivia/scripts/archive-helper.js","hash":"a0fcc99f909f668c1d3d2dd63e9911266f23fa57","modified":1702872644759},{"_id":"node_modules/hexo-theme-vivia/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1702872644730},{"_id":"node_modules/hexo-theme-vivia/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1702872644735},{"_id":"node_modules/hexo-theme-vivia/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1702872644731},{"_id":"node_modules/hexo-theme-vivia/layout/_icon/dark_mode.ejs","hash":"0ea0e23fb16103f424591cf46939fcf07738ccc1","modified":1702872644722},{"_id":"node_modules/hexo-theme-vivia/scripts/categories-process.js","hash":"dbb502b14015ca19b74db62a590319f790b28711","modified":1702872644759},{"_id":"node_modules/hexo-theme-vivia/scripts/color-generate.js","hash":"90dff57087b692d2aa687c49980a0eed56a2f058","modified":1702872644759},{"_id":"node_modules/hexo-theme-vivia/layout/_icon/menu.ejs","hash":"47f04d2c6413beaffee57d6164b5637bdb2cd1cb","modified":1702872644727},{"_id":"node_modules/hexo-theme-vivia/layout/_icon/navigate_before.ejs","hash":"1c11e29aa2719674b161c072e53576ac38b1ee65","modified":1702872644729},{"_id":"node_modules/hexo-theme-vivia/layout/_icon/navigate_next.ejs","hash":"c3ecb137ebc9bb949aebe3fc0631b05ba578c8e1","modified":1702872644730},{"_id":"node_modules/hexo-theme-vivia/layout/_icon/rss_feed.ejs","hash":"8bac3aa45c0e7a55f38783e7350039d0b1adb48b","modified":1702872644733},{"_id":"node_modules/hexo-theme-vivia/layout/_icon/wb_sunny.ejs","hash":"ef254cc64ba10918218a6672e34fd5f6d4ce08bb","modified":1702872644735},{"_id":"node_modules/hexo-theme-vivia/layout/_partial/archive.ejs","hash":"2106e7f5f73c9c8d592dcd7dab4359d23037f382","modified":1702872644715},{"_id":"node_modules/hexo-theme-vivia/layout/_partial/article.ejs","hash":"5f26c4dfc4ab6336122bfba92faf1630a2549d8d","modified":1702872644717},{"_id":"node_modules/hexo-theme-vivia/layout/_partial/archive-post.ejs","hash":"c7a71425a946d05414c069ec91811b5c09a92c47","modified":1702872644713},{"_id":"node_modules/hexo-theme-vivia/layout/_partial/back-to-top.ejs","hash":"a5132c5ab08b55891bcfe10d36ec83cacbfd60af","modified":1702872644718},{"_id":"node_modules/hexo-theme-vivia/layout/_partial/baidu-analytics.ejs","hash":"5951d0adc0490ff4d5c956e54d4828119755d1e7","modified":1702872644718},{"_id":"node_modules/hexo-theme-vivia/layout/_partial/google-analytics.ejs","hash":"2ea7442ea1e1a8ab4e41e26c563f58413b59a3d0","modified":1702872644725},{"_id":"node_modules/hexo-theme-vivia/layout/_partial/gauges-analytics.ejs","hash":"21a1e2a3907d1a3dad1cd0ab855fe6735f233c74","modified":1702872644724},{"_id":"node_modules/hexo-theme-vivia/layout/_partial/footer.ejs","hash":"e78a36c94879f70df2ec615ccc2b5d459eeb4fe7","modified":1702872644723},{"_id":"node_modules/hexo-theme-vivia/layout/_partial/banner.ejs","hash":"7f9c0b7d10238b45c1c1a65df7f801c904ae898c","modified":1702872644718},{"_id":"node_modules/hexo-theme-vivia/layout/_partial/head.ejs","hash":"b52fd8595ec4849944564721810e74948895675f","modified":1702872644725},{"_id":"node_modules/hexo-theme-vivia/layout/_partial/mobile-nav.ejs","hash":"e952a532dfc583930a666b9d4479c32d4a84b44e","modified":1702872644728},{"_id":"node_modules/hexo-theme-vivia/layout/_widget/archive.ejs","hash":"1dd3efd775f09f3e5a0e0205ddb8388851dfad57","modified":1702872644716},{"_id":"node_modules/hexo-theme-vivia/layout/_partial/navbar.ejs","hash":"7d4a434cba72a3bca58b59fab4ce15894da68049","modified":1702872644729},{"_id":"node_modules/hexo-theme-vivia/layout/_partial/sidebar.ejs","hash":"97eee27bfb59ccc109fcd9ce87963f686c2b6ba9","modified":1702872644733},{"_id":"node_modules/hexo-theme-vivia/layout/_widget/color.ejs","hash":"9e00f6c621db3c5c659b03d1dad6caa90d6217d9","modified":1702872644721},{"_id":"node_modules/hexo-theme-vivia/source/css/_extend.styl","hash":"cc37f2c5f8ccdb77f87cf8ed35ea71a2d66c9605","modified":1702872644813},{"_id":"node_modules/hexo-theme-vivia/layout/_widget/category.ejs","hash":"cc465be58bf6aeee7947e9cf9563c651e42e7a5d","modified":1702872644720},{"_id":"node_modules/hexo-theme-vivia/layout/_widget/profile.ejs","hash":"ccd8c2442f3437b6752946f4d573edefaf2cd4c0","modified":1702872644731},{"_id":"node_modules/hexo-theme-vivia/source/css/style.styl","hash":"a24d0d9ef5f292bfe3382435d23ffe5a6fa76354","modified":1702872644829},{"_id":"node_modules/hexo-theme-vivia/layout/_widget/recent_posts.ejs","hash":"647f4151e7fca48af2b727228b84deb0652a6376","modified":1702872644732},{"_id":"node_modules/hexo-theme-vivia/source/css/_variables.styl","hash":"376b7ccf4d4ef0706b3e45c059184a41cdde52c7","modified":1702872644818},{"_id":"node_modules/hexo-theme-vivia/layout/_widget/tag.ejs","hash":"f231a62130014c07dc1888ed30399bcfde3ed0c0","modified":1702872644734},{"_id":"node_modules/hexo-theme-vivia/source/images/favicon-dark-192.png","hash":"929acfdd6e69ceacdecf40a03ed520f826750c06","modified":1702872644805},{"_id":"node_modules/hexo-theme-vivia/source/images/favicon-dark-128.png","hash":"44cceeef5fddc81a613faf6caa53bac139a6b564","modified":1702872644803},{"_id":"node_modules/hexo-theme-vivia/source/images/favicon-dark-180.png","hash":"4771a6bd0386924ad31719f8999c036b36ad5688","modified":1702872644804},{"_id":"node_modules/hexo-theme-vivia/source/images/favicon-dark-32.png","hash":"8ef87b664e5c6250e5badd7312fe192e30fe2e83","modified":1702872644806},{"_id":"node_modules/hexo-theme-vivia/source/images/favicon-light-128.png","hash":"9c93c4ac222da14ca4f43b2d54573ce4099a161b","modified":1702872644806},{"_id":"node_modules/hexo-theme-vivia/source/images/favicon-light-180.png","hash":"6b26caab1d036726beaf47510bada4cddf253b24","modified":1702872644809},{"_id":"node_modules/hexo-theme-vivia/source/images/favicon-light-192.png","hash":"0d5f76f309b6a0661d695d6bf4db8ef8a56e4ae5","modified":1702872644811},{"_id":"node_modules/hexo-theme-vivia/source/images/favicon-light-32.png","hash":"604915a91ddede7874d5dcfa4de0bc4b04ae5da6","modified":1702872644812},{"_id":"node_modules/hexo-theme-vivia/source/js/load-settings.js","hash":"f420677aad3d200b4f92fca60ab5cb47c7db9a21","modified":1702872644768},{"_id":"node_modules/hexo-theme-vivia/source/images/tile.png","hash":"fbc016bfb004a5ca4a8c6f0b078ae320ec98ba20","modified":1702872644812},{"_id":"node_modules/hexo-theme-vivia/source/js/color.global.min.js","hash":"8140005be5afebb828b2890ce6e686ece34e78df","modified":1702872644765},{"_id":"node_modules/hexo-theme-vivia/source/js/script.js","hash":"998ed4c5b147e1299bf62beebf33514474f28112","modified":1702872644769},{"_id":"node_modules/hexo-theme-vivia/source/js/light-dark-switch.js","hash":"371eacee9af459d04de60190c549fe7f8374be36","modified":1702872644768},{"_id":"node_modules/hexo-theme-vivia/layout/_partial/post/date.ejs","hash":"760970e719ef973c18ac36c9fc9e13d0edaaaa5a","modified":1702872644723},{"_id":"node_modules/hexo-theme-vivia/layout/_partial/post/category.ejs","hash":"9f06ff87e50ff5005080c6bdebf4a0bbaf550aba","modified":1702872644719},{"_id":"node_modules/hexo-theme-vivia/layout/_partial/post/gallery.ejs","hash":"0282d116251bd60b91e05c786386e4d570035996","modified":1702872644724},{"_id":"node_modules/hexo-theme-vivia/layout/_partial/post/nav.ejs","hash":"86886e1ca10aec7087b44048f92719d24ac738f4","modified":1702872644728},{"_id":"node_modules/hexo-theme-vivia/layout/_partial/post/tag.ejs","hash":"2fcb0bf9c8847a644167a27824c9bb19ac74dd14","modified":1702872644734},{"_id":"node_modules/hexo-theme-vivia/layout/_partial/post/title.ejs","hash":"14e34508135bf83763d8c1f1f8d8467dff689002","modified":1702872644735},{"_id":"node_modules/hexo-theme-vivia/source/css/_partial/archive.styl","hash":"ee7b27115aed0182dc9ac51b637a2bf986b56f55","modified":1702872644819},{"_id":"node_modules/hexo-theme-vivia/source/css/_partial/article.styl","hash":"9e8ec0aa97f6a21a54b0bbe29f0943892eb465e3","modified":1702872644819},{"_id":"node_modules/hexo-theme-vivia/source/css/_partial/comment.styl","hash":"08253d81e739c4074d5ae697f2ca9068355dae2c","modified":1702872644821},{"_id":"node_modules/hexo-theme-vivia/source/css/_partial/back-to-top.styl","hash":"0889a434c03d9fded8820ebbeaa5357d725766b6","modified":1702872644820},{"_id":"node_modules/hexo-theme-vivia/source/css/_partial/footer.styl","hash":"f038558bfe427b2cedd029cb9638c1d70d936763","modified":1702872644822},{"_id":"node_modules/hexo-theme-vivia/source/css/_partial/header.styl","hash":"83633c613f0d4ad6caa82f87795799edde29fbb8","modified":1702872644823},{"_id":"node_modules/hexo-theme-vivia/source/css/_partial/highlight.styl","hash":"3abb118aae2dba149cb616bbcbfed129ccfcb5b7","modified":1702872644824},{"_id":"node_modules/hexo-theme-vivia/source/css/_partial/main-title.styl","hash":"73df1241b15d62cc19665883cd789440d4c7e7a6","modified":1702872644825},{"_id":"node_modules/hexo-theme-vivia/source/css/_partial/settings.styl","hash":"6e67f8c3659f6a9dd49e513a595a01c1afebf87c","modified":1702872644826},{"_id":"node_modules/hexo-theme-vivia/source/css/_partial/sidebar-aside.styl","hash":"04a0c9f6b86d62069a1349fdb7803d745759fe38","modified":1702872644826},{"_id":"node_modules/hexo-theme-vivia/source/css/_partial/sidebar-bottom.styl","hash":"8fd4f30d319542babfd31f087ddbac550f000a8a","modified":1702872644827},{"_id":"node_modules/hexo-theme-vivia/source/css/_partial/sidebar.styl","hash":"69a08fe059c5e2ee00760ae61f1123d61d90c39a","modified":1702872644827},{"_id":"node_modules/hexo-theme-vivia/source/css/_util/color.styl","hash":"8ad148e35b7cb2a0612ff2c0fb09c0acc382bb5e","modified":1702872644821},{"_id":"node_modules/hexo-theme-vivia/source/css/_util/grid.styl","hash":"0bf55ee5d09f193e249083602ac5fcdb1e571aed","modified":1702872644823},{"_id":"node_modules/hexo-theme-vivia/source/css/_util/mixin.styl","hash":"44f32767d9fd3c1c08a60d91f181ee53c8f0dbb3","modified":1702872644825},{"_id":"node_modules/hexo-theme-vivia/source/fontawesome/css/brands.css","hash":"8c4c541bc40f83787c6987e3ac681e4d3faa54c1","modified":1702872644680},{"_id":"node_modules/hexo-theme-vivia/source/fontawesome/css/brands.min.css","hash":"18b8f500bb4f772c7d7f39c3fab1478a74825339","modified":1702872644681},{"_id":"node_modules/hexo-theme-vivia/source/fontawesome/css/regular.css","hash":"f9334e2a68dce5b03b07148ac9a93c5ad98fe99e","modified":1702872644703},{"_id":"node_modules/hexo-theme-vivia/source/fontawesome/css/regular.min.css","hash":"659c14600584effc4b93be03a0160b21a90923b8","modified":1702872644704},{"_id":"node_modules/hexo-theme-vivia/source/fontawesome/css/solid.css","hash":"28c2b2461ee1078694ce253ae772f125ae4fa0ac","modified":1702872644704},{"_id":"node_modules/hexo-theme-vivia/source/fontawesome/css/solid.min.css","hash":"876c898134a50c7b8e42314fba36fdfef7df3a6e","modified":1702872644705},{"_id":"node_modules/hexo-theme-vivia/source/fontawesome/css/svg-with-js.css","hash":"fb14f74f1ee5072ca4b6d79850616816d57789dd","modified":1702872644706},{"_id":"node_modules/hexo-theme-vivia/source/fontawesome/css/svg-with-js.min.css","hash":"b488e7f51b974eb12138921b606359553e7b6d3d","modified":1702872644707},{"_id":"node_modules/hexo-theme-vivia/source/fontawesome/css/v4-font-face.min.css","hash":"f32930ff09bccce04156af99f31231387af624f6","modified":1702872644708},{"_id":"node_modules/hexo-theme-vivia/source/fontawesome/css/v4-font-face.css","hash":"b266ee63ab30304fefbf89faff2bc8d0c61b9149","modified":1702872644708},{"_id":"node_modules/hexo-theme-vivia/source/fontawesome/css/v4-shims.min.css","hash":"791742cd5dd90f208489f835d3924ee325695920","modified":1702872644711},{"_id":"node_modules/hexo-theme-vivia/source/fontawesome/css/v4-shims.css","hash":"2e9933089ede320ba8c67509e0355aab49c5d293","modified":1702872644709},{"_id":"node_modules/hexo-theme-vivia/source/fontawesome/css/v5-font-face.min.css","hash":"9b1d63f200b06ff5c6a306bd4c4404db38e78866","modified":1702872644712},{"_id":"node_modules/hexo-theme-vivia/source/fontawesome/css/v5-font-face.css","hash":"f5fac79059b214cf7e82de28544d9685cc1db3bc","modified":1702872644712},{"_id":"node_modules/hexo-theme-vivia/source/fontawesome/webfonts/fa-regular-400.ttf","hash":"dad3ad71b383789bb62c249742ef59e34685e7d0","modified":1702872644891},{"_id":"node_modules/hexo-theme-vivia/source/fontawesome/webfonts/fa-regular-400.woff2","hash":"3119676750af0e0bc338cc4aad220bdc72c56cc5","modified":1702872645077},{"_id":"node_modules/hexo-theme-vivia/source/fontawesome/webfonts/fa-v4compatibility.ttf","hash":"52a84a6495e27f43e9762f2c2a9531d9fe15e9ee","modified":1702872644927},{"_id":"node_modules/hexo-theme-vivia/source/fontawesome/webfonts/fa-v4compatibility.woff2","hash":"dd7e4a76de26e9e39168dfac3fbb8a34a87b76bc","modified":1702872645157},{"_id":"node_modules/hexo-theme-vivia/source/js/jquery-3.4.1.min.js","hash":"88523924351bac0b5d560fe0c5781e2556e7693d","modified":1702872644767},{"_id":"node_modules/hexo-theme-vivia/source/css/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1702872645033},{"_id":"node_modules/hexo-theme-vivia/source/css/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1702872645166},{"_id":"node_modules/hexo-theme-vivia/source/fontawesome/css/all.min.css","hash":"686e3160cff3fb1be2de10779754b40f15948208","modified":1702872644678},{"_id":"node_modules/hexo-theme-vivia/source/fontawesome/css/fontawesome.css","hash":"f1239ac4cd2cf265ed3fa0e5ca8733d9a10ffd68","modified":1702872644686},{"_id":"node_modules/hexo-theme-vivia/source/fontawesome/css/fontawesome.min.css","hash":"24ae04e00c6b58ae5b6dfcf7ca06acb3bd92d7e5","modified":1702872644702},{"_id":"node_modules/hexo-theme-vivia/source/fontawesome/webfonts/fa-brands-400.woff2","hash":"b99813b3c531d8fe90aed3b75d2ed71f8e0c87f4","modified":1702872645072},{"_id":"node_modules/hexo-theme-vivia/source/css/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1702872644802},{"_id":"node_modules/hexo-theme-vivia/source/css/fonts/Roboto-Bold.ttf","hash":"62442a18a9fe9457c1afeabf683d263a691b7798","modified":1702872644969},{"_id":"node_modules/hexo-theme-vivia/source/css/fonts/Roboto-Regular.ttf","hash":"56c5c0d38bde4c1f1549dda43db37b09c608aad3","modified":1702872645009},{"_id":"node_modules/hexo-theme-vivia/source/css/fonts/Roboto-Medium.ttf","hash":"3c6a09fcc6a454924c81af7dff94fc6d399ed79b","modified":1702872644992},{"_id":"node_modules/hexo-theme-vivia/source/css/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1702872644757},{"_id":"node_modules/hexo-theme-vivia/source/css/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1702872644947},{"_id":"node_modules/hexo-theme-vivia/source/fontawesome/css/all.css","hash":"e487581ce484a609b9cfe6c6e3faf70f933c7628","modified":1702872644661},{"_id":"node_modules/hexo-theme-vivia/source/fontawesome/webfonts/fa-brands-400.ttf","hash":"a14a91d8c170fc9e159040f6794369d829e0859e","modified":1702872644877},{"_id":"node_modules/hexo-theme-vivia/source/fontawesome/webfonts/fa-solid-900.woff2","hash":"c0e6e76b4a02c34656ff2a41b671e02f2821829b","modified":1702872645155},{"_id":"node_modules/hexo-theme-vivia/source/css/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1702872644845},{"_id":"node_modules/hexo-theme-vivia/source/fontawesome/webfonts/fa-solid-900.ttf","hash":"3eb9b4b2ea22711b96e3b356196fd20b4f17fb0e","modified":1702872644926},{"_id":"source/assets/bg1.jpg","hash":"8dafeca6512a9bb6916f814ca11e0146baaddc13","modified":1688132486960},{"_id":"public/about/index.html","hash":"e151082c235354d04557475a446195680b3f3bc8","modified":1754043760921},{"_id":"public/archives/index.html","hash":"261f70e4d73062d1d5363d5f3373b155045e0123","modified":1754043760921},{"_id":"public/2025/08/01/C610-电调-CAN-通信协议Arduino-Mega2560使用指南/index.html","hash":"3b74825f146e901a5e7e875ec1ee6433420f66ed","modified":1754043760921},{"_id":"public/archives/2025/index.html","hash":"8eb402eb4e7c65c1a648c1d8407ac6719d14c79e","modified":1754043760921},{"_id":"public/archives/2025/08/index.html","hash":"084db173326e806fc48007828045c4373cc6201f","modified":1754043760921},{"_id":"public/index.html","hash":"b03a2e15d14165ad610a2cb75c7c0056466b0f47","modified":1754043760921},{"_id":"public/images/favicon-dark-128.png","hash":"44cceeef5fddc81a613faf6caa53bac139a6b564","modified":1754034954803},{"_id":"public/images/favicon-dark-180.png","hash":"4771a6bd0386924ad31719f8999c036b36ad5688","modified":1754034954803},{"_id":"public/images/favicon-dark-32.png","hash":"8ef87b664e5c6250e5badd7312fe192e30fe2e83","modified":1754034954803},{"_id":"public/images/favicon-dark-192.png","hash":"929acfdd6e69ceacdecf40a03ed520f826750c06","modified":1754034954803},{"_id":"public/images/favicon-light-180.png","hash":"6b26caab1d036726beaf47510bada4cddf253b24","modified":1754034954803},{"_id":"public/images/favicon-light-128.png","hash":"9c93c4ac222da14ca4f43b2d54573ce4099a161b","modified":1754034954803},{"_id":"public/images/favicon-light-192.png","hash":"0d5f76f309b6a0661d695d6bf4db8ef8a56e4ae5","modified":1754034954803},{"_id":"public/images/favicon-light-32.png","hash":"604915a91ddede7874d5dcfa4de0bc4b04ae5da6","modified":1754034954803},{"_id":"public/images/tile.png","hash":"fbc016bfb004a5ca4a8c6f0b078ae320ec98ba20","modified":1754034954803},{"_id":"public/fontawesome/webfonts/fa-regular-400.ttf","hash":"dad3ad71b383789bb62c249742ef59e34685e7d0","modified":1754034954803},{"_id":"public/fontawesome/webfonts/fa-regular-400.woff2","hash":"3119676750af0e0bc338cc4aad220bdc72c56cc5","modified":1754034954803},{"_id":"public/css/style.css","hash":"d133f4a4199b4bacc057c72c635503d06e6cff0f","modified":1754034954803},{"_id":"public/js/light-dark-switch.js","hash":"371eacee9af459d04de60190c549fe7f8374be36","modified":1754034954803},{"_id":"public/js/color.global.min.js","hash":"8140005be5afebb828b2890ce6e686ece34e78df","modified":1754034954803},{"_id":"public/js/load-settings.js","hash":"f420677aad3d200b4f92fca60ab5cb47c7db9a21","modified":1754034954803},{"_id":"public/js/jquery-3.4.1.min.js","hash":"88523924351bac0b5d560fe0c5781e2556e7693d","modified":1754034954803},{"_id":"public/js/script.js","hash":"998ed4c5b147e1299bf62beebf33514474f28112","modified":1754034954803},{"_id":"public/fontawesome/css/brands.css","hash":"8c4c541bc40f83787c6987e3ac681e4d3faa54c1","modified":1754034954803},{"_id":"public/fontawesome/css/all.css","hash":"e487581ce484a609b9cfe6c6e3faf70f933c7628","modified":1754034954803},{"_id":"public/fontawesome/css/brands.min.css","hash":"18b8f500bb4f772c7d7f39c3fab1478a74825339","modified":1754034954803},{"_id":"public/fontawesome/css/regular.css","hash":"f9334e2a68dce5b03b07148ac9a93c5ad98fe99e","modified":1754034954803},{"_id":"public/fontawesome/css/regular.min.css","hash":"659c14600584effc4b93be03a0160b21a90923b8","modified":1754034954803},{"_id":"public/fontawesome/css/all.min.css","hash":"686e3160cff3fb1be2de10779754b40f15948208","modified":1754034954803},{"_id":"public/fontawesome/css/fontawesome.css","hash":"f1239ac4cd2cf265ed3fa0e5ca8733d9a10ffd68","modified":1754034954803},{"_id":"public/fontawesome/css/fontawesome.min.css","hash":"24ae04e00c6b58ae5b6dfcf7ca06acb3bd92d7e5","modified":1754034954803},{"_id":"public/fontawesome/webfonts/fa-v4compatibility.woff2","hash":"dd7e4a76de26e9e39168dfac3fbb8a34a87b76bc","modified":1754034954803},{"_id":"public/fontawesome/webfonts/fa-v4compatibility.ttf","hash":"52a84a6495e27f43e9762f2c2a9531d9fe15e9ee","modified":1754034954803},{"_id":"public/css/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1754034954803},{"_id":"public/css/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1754034954803},{"_id":"public/fontawesome/webfonts/fa-brands-400.woff2","hash":"b99813b3c531d8fe90aed3b75d2ed71f8e0c87f4","modified":1754034954803},{"_id":"public/fontawesome/css/solid.min.css","hash":"876c898134a50c7b8e42314fba36fdfef7df3a6e","modified":1754034954803},{"_id":"public/fontawesome/css/solid.css","hash":"28c2b2461ee1078694ce253ae772f125ae4fa0ac","modified":1754034954803},{"_id":"public/fontawesome/css/svg-with-js.css","hash":"fb14f74f1ee5072ca4b6d79850616816d57789dd","modified":1754034954803},{"_id":"public/fontawesome/css/svg-with-js.min.css","hash":"b488e7f51b974eb12138921b606359553e7b6d3d","modified":1754034954803},{"_id":"public/fontawesome/css/v4-font-face.css","hash":"b266ee63ab30304fefbf89faff2bc8d0c61b9149","modified":1754034954803},{"_id":"public/fontawesome/css/v4-font-face.min.css","hash":"f32930ff09bccce04156af99f31231387af624f6","modified":1754034954803},{"_id":"public/fontawesome/css/v4-shims.css","hash":"2e9933089ede320ba8c67509e0355aab49c5d293","modified":1754034954803},{"_id":"public/fontawesome/css/v5-font-face.css","hash":"f5fac79059b214cf7e82de28544d9685cc1db3bc","modified":1754034954803},{"_id":"public/fontawesome/css/v5-font-face.min.css","hash":"9b1d63f200b06ff5c6a306bd4c4404db38e78866","modified":1754034954803},{"_id":"public/fontawesome/css/v4-shims.min.css","hash":"791742cd5dd90f208489f835d3924ee325695920","modified":1754034954803},{"_id":"public/css/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1754034954803},{"_id":"public/css/fonts/Roboto-Bold.ttf","hash":"62442a18a9fe9457c1afeabf683d263a691b7798","modified":1754034954803},{"_id":"public/css/fonts/Roboto-Regular.ttf","hash":"56c5c0d38bde4c1f1549dda43db37b09c608aad3","modified":1754034954803},{"_id":"public/css/fonts/Roboto-Medium.ttf","hash":"3c6a09fcc6a454924c81af7dff94fc6d399ed79b","modified":1754034954803},{"_id":"public/css/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1754034954803},{"_id":"public/css/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1754034954803},{"_id":"public/fontawesome/webfonts/fa-brands-400.ttf","hash":"a14a91d8c170fc9e159040f6794369d829e0859e","modified":1754034954803},{"_id":"public/fontawesome/webfonts/fa-solid-900.woff2","hash":"c0e6e76b4a02c34656ff2a41b671e02f2821829b","modified":1754034954803},{"_id":"public/assets/head.jpg","hash":"8ab556517042c2108ea5bb83c663a16e566fde80","modified":1754034954803},{"_id":"public/css/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1754034954803},{"_id":"public/fontawesome/webfonts/fa-solid-900.ttf","hash":"3eb9b4b2ea22711b96e3b356196fd20b4f17fb0e","modified":1754034954803},{"_id":"public/assets/bg1.jpg","hash":"8dafeca6512a9bb6916f814ca11e0146baaddc13","modified":1754034954803},{"_id":"source/_posts/2021-04-30-C语言指针到底是个什么东西.md","hash":"0b002925af00efdc3ca896c3ee195d63720963a3","modified":1754042089775},{"_id":"public/2021/04/30/C语言指针到底是个什么东西/index.html","hash":"4fd765f9870cd92789ce41c84293b46343450633","modified":1754043760921},{"_id":"public/archives/2021/index.html","hash":"7f4e0be8bf0030cdb08f02ff8a898644d4efd139","modified":1754043760921},{"_id":"public/archives/2021/04/index.html","hash":"7b17a0beadb1ad01ec070722d110f4ac4281c1e1","modified":1754043760921},{"_id":"source/_posts/2022-04-30-Makefile-入门：从基础到实用技巧.md","hash":"033c9174b5b2e19e6b54732c87a32493b11f230f","modified":1754043738488},{"_id":"public/2022/04/30/Makefile-入门：从基础到实用技巧/index.html","hash":"7b8e89ab5126d7e7b84858def2fb46d11842879a","modified":1754043760921},{"_id":"public/archives/2022/index.html","hash":"9047eba7ef5e67b7abfb57cda6ba873b22e6a072","modified":1754043760921},{"_id":"public/archives/2022/04/index.html","hash":"830468f05f477d5ff15caf141f8739f8d2bd3e6d","modified":1754043760921}],"Category":[],"Data":[],"Page":[{"title":"about","date":"2023-12-18T04:12:36.000Z","_content":"","source":"about/index.md","raw":"---\ntitle: about\ndate: 2023-12-18 12:12:36\n---\n","updated":"2023-12-18T04:12:36.630Z","path":"about/index.html","comments":1,"layout":"page","_id":"cmdsj4hd4000038li3oildeho","content":"","site":{"data":{}},"length":0,"excerpt":"","more":""}],"Post":[{"title":"C610 电调 CAN 通信协议Arduino Mega2560使用指南","date":"2025-08-01T07:39:25.000Z","_content":"# C610电调CAN通信协议及使用指南\n\n\n## 基本信息及资料\n\n- **通信协议**：C610电调采用CAN通信协议\n- **协议参考文档**：40. CAN—通讯实验 — [野火]STM32 HAL库开发实战指南——基于H743_Pro_V\n- **硬件适配**：Arduino Mega2560无CAN差分信号引脚，需外接MCP2515（实现CAN差分信号与SPI信号转换）\n- **推荐库**：[GitHub - autowp/arduino-mcp2515](https://github.com/autowp/arduino-mcp2515)（Arduino MCP2515 CAN接口库）\n\n\n## 报文接收格式\n用于向电调发送控制指令控制电调的电流输出,两个标识符(0x200和0x1FF)各自对应 控制4个ID的电调。控制转矩电流值范围-10000-0-10000,对应电调输出的转矩电流 范围-10-0-10A。\n\n即0x200用于控制1-4号电调\n\n| 数据域   | 内容             | 电调ID |\n|----------|------------------|--------|\n| DATA[0]  | 控制电流值高8位 | 1      |\n| DATA[1]  | 控制电流值低8位 | 1      |\n| DATA[2]  | 控制电流值高8位 | 2      |\n| DATA[3]  | 控制电流值低8位 | 2      |\n| DATA[4]  | 控制电流值高8位 | 3      |\n| DATA[5]  | 控制电流值低8位 | 3      |\n| DATA[6]  | 控制电流值高8位 | 4      |\n| DATA[7]  | 控制电流值低8位 | 4      |\n\n0x1FF用于控制5-8号电调\n\n| 数据域   | 内容             | 电调ID |\n|----------|------------------|--------|\n| DATA[0]  | 控制电流值高8位 | 5      |\n| DATA[1]  | 控制电流值低8位 | 5      |\n| DATA[2]  | 控制电流值高8位 | 6      |\n| DATA[3]  | 控制电流值低8位 | 6      |\n| DATA[4]  | 控制电流值高8位 | 7      |\n| DATA[5]  | 控制电流值低8位 | 7      |\n| DATA[6]  | 控制电流值高8位 | 8      |\n| DATA[7]  | 控制电流值低8位 | 8      |\n\n\n\n## 报文反馈格式\n\n### 数据域定义\n| 数据索引 | 内容                 |\n|----------|----------------------|\n| DATA[0]  | 转子机械角度高8位    |\n| DATA[1]  | 转子机械角度低8位    |\n| DATA[2]  | 转子转速高8位        |\n| DATA[3]  | 转子转速低8位        |\n| DATA[4]  | 实际输出转矩高8位    |\n| DATA[5]  | 实际输出转矩低8位    |\n| DATA[6]  | Null                 |\n| DATA[7]  | Null                 |\n\n接收数据时的CANID若为`0x201`则为ID为1的电调的数据，以此类推。\n若是ID为`0x1FF+ID`则为ID为5-8的电调的数据。\n\n### 关键参数\n- 发送频率：默认1KHz（可通过RoboMaster Assistant软件修改）\n- 转子机械角度范围：0~8191（对应物理角度0~360°）\n- 转子转速单位：rpm（转/分钟）\n\n\n## 高8位与低8位的理解\n\nC610电调中16位数据会拆分为高8位和低8位传输，具体说明如下：\n\n1. **数据拆分逻辑**：  \n   16位原始数据（如二进制`0011 0000 1100 0100`）拆分为：  \n   - 高8位：`0011 0000`（通过16位数据右移8位获取：`原始数据 >> 8`）  \n   - 低8位：`1100 0100`（直接截取原始数据的低8位）  \n\n2. **赋值方式**：  \n   高8位赋值给`DATA[n]`，低8位赋值给`DATA[n+1]`（如角度数据中，`DATA[0]`存高8位，`DATA[1]`存低8位）\n\n## CAN数据包解析方法\n\n解析接收的CAN数据是拆分过程的逆操作，步骤如下：\n\n1. 将高8位数据（如`DATA[0]`）转换为16位变量（自动补高位0，例：`0011 0000`→`0000 0000 0011 0000`）；  \n2. 将高8位数据左移8位（例：`0000 0000 0011 0000 << 8`→`0011 0000 0000 0000`）；  \n3. 与低8位数据（如`DATA[1]`）相加，还原16位原始数据（例：`0011 0000 0000 0000 + 1100 0100`→`0011 0000 1100 0100`）；  \n4. 转换为十进制输出即得目标数据。\n\n\n## 示例程序\n\n```cpp\n#include <SPI.h>\n#include <mcp2515.h>\n\nstruct can_frame canMsg;\nstruct can_frame canMsg1;\nMCP2515 mcp2515(10);  // 初始化MCP2515，CS引脚为10\n\nint16_t current = 1000;         // 设定电流值\nint16_t result_angle = 0;       // 解析后的角度值\nint16_t result_torque = 0;      // 解析后的转矩值\nint16_t result_speed = 0;       // 解析后的转速值\n\nvoid setup() {\n  Serial.begin(115200);  // 初始化串口通信\n\n  // 初始化MCP2515\n  mcp2515.reset();\n  mcp2515.setBitrate(CAN_1000KBPS, MCP_8MHZ);  // 波特率1000KBPS，时钟8MHz\n  mcp2515.setNormalMode();\n\n  // 配置发送报文\n  canMsg1.can_id  = 0x200;       // 报文ID\n  canMsg1.can_dlc = 8;           // 数据长度8字节\n  // 填充数据（高8位与低8位拆分）\n  canMsg1.data[0] = (current >> 8);\n  canMsg1.data[1] = current;\n  canMsg1.data[2] = (current >> 8);\n  canMsg1.data[3] = current;\n  canMsg1.data[4] = (current >> 8);\n  canMsg1.data[5] = current;\n  canMsg1.data[6] = (current >> 8);\n  canMsg1.data[7] = current;\n}\n\nvoid loop() {\n  // 发送报文\n  mcp2515.sendMessage(&canMsg1);\n\n  // 接收并解析报文\n  if (mcp2515.readMessage(&canMsg) == MCP2515::ERROR_OK) {\n    Serial.print(canMsg.can_id, HEX);  // 输出CAN ID（十六进制）\n    Serial.print(\" \");\n    Serial.print(canMsg.can_dlc, HEX); // 输出数据长度（十六进制）\n    Serial.print(\" \");\n    \n    // 解析转子转速（高8位左移8位+低8位）\n    Serial.print(\"转子转速：\");\n    result_speed = ((uint16_t)canMsg.data[2] << 8) + canMsg.data[3];\n    Serial.print(result_speed / 36, DEC);  // 输出转速（十进制）\n    Serial.print(\"; \");\n  }\n}\n```","source":"_posts/2025-08-01-C610-电调-CAN-通信协议Arduino-Mega2560使用指南.md","raw":"---\ntitle: C610 电调 CAN 通信协议Arduino Mega2560使用指南\ndate: 2025-08-01 15:39:25\ntags:\n---\n# C610电调CAN通信协议及使用指南\n\n\n## 基本信息及资料\n\n- **通信协议**：C610电调采用CAN通信协议\n- **协议参考文档**：40. CAN—通讯实验 — [野火]STM32 HAL库开发实战指南——基于H743_Pro_V\n- **硬件适配**：Arduino Mega2560无CAN差分信号引脚，需外接MCP2515（实现CAN差分信号与SPI信号转换）\n- **推荐库**：[GitHub - autowp/arduino-mcp2515](https://github.com/autowp/arduino-mcp2515)（Arduino MCP2515 CAN接口库）\n\n\n## 报文接收格式\n用于向电调发送控制指令控制电调的电流输出,两个标识符(0x200和0x1FF)各自对应 控制4个ID的电调。控制转矩电流值范围-10000-0-10000,对应电调输出的转矩电流 范围-10-0-10A。\n\n即0x200用于控制1-4号电调\n\n| 数据域   | 内容             | 电调ID |\n|----------|------------------|--------|\n| DATA[0]  | 控制电流值高8位 | 1      |\n| DATA[1]  | 控制电流值低8位 | 1      |\n| DATA[2]  | 控制电流值高8位 | 2      |\n| DATA[3]  | 控制电流值低8位 | 2      |\n| DATA[4]  | 控制电流值高8位 | 3      |\n| DATA[5]  | 控制电流值低8位 | 3      |\n| DATA[6]  | 控制电流值高8位 | 4      |\n| DATA[7]  | 控制电流值低8位 | 4      |\n\n0x1FF用于控制5-8号电调\n\n| 数据域   | 内容             | 电调ID |\n|----------|------------------|--------|\n| DATA[0]  | 控制电流值高8位 | 5      |\n| DATA[1]  | 控制电流值低8位 | 5      |\n| DATA[2]  | 控制电流值高8位 | 6      |\n| DATA[3]  | 控制电流值低8位 | 6      |\n| DATA[4]  | 控制电流值高8位 | 7      |\n| DATA[5]  | 控制电流值低8位 | 7      |\n| DATA[6]  | 控制电流值高8位 | 8      |\n| DATA[7]  | 控制电流值低8位 | 8      |\n\n\n\n## 报文反馈格式\n\n### 数据域定义\n| 数据索引 | 内容                 |\n|----------|----------------------|\n| DATA[0]  | 转子机械角度高8位    |\n| DATA[1]  | 转子机械角度低8位    |\n| DATA[2]  | 转子转速高8位        |\n| DATA[3]  | 转子转速低8位        |\n| DATA[4]  | 实际输出转矩高8位    |\n| DATA[5]  | 实际输出转矩低8位    |\n| DATA[6]  | Null                 |\n| DATA[7]  | Null                 |\n\n接收数据时的CANID若为`0x201`则为ID为1的电调的数据，以此类推。\n若是ID为`0x1FF+ID`则为ID为5-8的电调的数据。\n\n### 关键参数\n- 发送频率：默认1KHz（可通过RoboMaster Assistant软件修改）\n- 转子机械角度范围：0~8191（对应物理角度0~360°）\n- 转子转速单位：rpm（转/分钟）\n\n\n## 高8位与低8位的理解\n\nC610电调中16位数据会拆分为高8位和低8位传输，具体说明如下：\n\n1. **数据拆分逻辑**：  \n   16位原始数据（如二进制`0011 0000 1100 0100`）拆分为：  \n   - 高8位：`0011 0000`（通过16位数据右移8位获取：`原始数据 >> 8`）  \n   - 低8位：`1100 0100`（直接截取原始数据的低8位）  \n\n2. **赋值方式**：  \n   高8位赋值给`DATA[n]`，低8位赋值给`DATA[n+1]`（如角度数据中，`DATA[0]`存高8位，`DATA[1]`存低8位）\n\n## CAN数据包解析方法\n\n解析接收的CAN数据是拆分过程的逆操作，步骤如下：\n\n1. 将高8位数据（如`DATA[0]`）转换为16位变量（自动补高位0，例：`0011 0000`→`0000 0000 0011 0000`）；  \n2. 将高8位数据左移8位（例：`0000 0000 0011 0000 << 8`→`0011 0000 0000 0000`）；  \n3. 与低8位数据（如`DATA[1]`）相加，还原16位原始数据（例：`0011 0000 0000 0000 + 1100 0100`→`0011 0000 1100 0100`）；  \n4. 转换为十进制输出即得目标数据。\n\n\n## 示例程序\n\n```cpp\n#include <SPI.h>\n#include <mcp2515.h>\n\nstruct can_frame canMsg;\nstruct can_frame canMsg1;\nMCP2515 mcp2515(10);  // 初始化MCP2515，CS引脚为10\n\nint16_t current = 1000;         // 设定电流值\nint16_t result_angle = 0;       // 解析后的角度值\nint16_t result_torque = 0;      // 解析后的转矩值\nint16_t result_speed = 0;       // 解析后的转速值\n\nvoid setup() {\n  Serial.begin(115200);  // 初始化串口通信\n\n  // 初始化MCP2515\n  mcp2515.reset();\n  mcp2515.setBitrate(CAN_1000KBPS, MCP_8MHZ);  // 波特率1000KBPS，时钟8MHz\n  mcp2515.setNormalMode();\n\n  // 配置发送报文\n  canMsg1.can_id  = 0x200;       // 报文ID\n  canMsg1.can_dlc = 8;           // 数据长度8字节\n  // 填充数据（高8位与低8位拆分）\n  canMsg1.data[0] = (current >> 8);\n  canMsg1.data[1] = current;\n  canMsg1.data[2] = (current >> 8);\n  canMsg1.data[3] = current;\n  canMsg1.data[4] = (current >> 8);\n  canMsg1.data[5] = current;\n  canMsg1.data[6] = (current >> 8);\n  canMsg1.data[7] = current;\n}\n\nvoid loop() {\n  // 发送报文\n  mcp2515.sendMessage(&canMsg1);\n\n  // 接收并解析报文\n  if (mcp2515.readMessage(&canMsg) == MCP2515::ERROR_OK) {\n    Serial.print(canMsg.can_id, HEX);  // 输出CAN ID（十六进制）\n    Serial.print(\" \");\n    Serial.print(canMsg.can_dlc, HEX); // 输出数据长度（十六进制）\n    Serial.print(\" \");\n    \n    // 解析转子转速（高8位左移8位+低8位）\n    Serial.print(\"转子转速：\");\n    result_speed = ((uint16_t)canMsg.data[2] << 8) + canMsg.data[3];\n    Serial.print(result_speed / 36, DEC);  // 输出转速（十进制）\n    Serial.print(\"; \");\n  }\n}\n```","slug":"C610-电调-CAN-通信协议Arduino-Mega2560使用指南","published":1,"updated":"2025-08-01T08:25:45.726Z","_id":"cmdsj4hd6000138li1am4fhqj","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"C610电调CAN通信协议及使用指南\"><a href=\"#C610电调CAN通信协议及使用指南\" class=\"headerlink\" title=\"C610电调CAN通信协议及使用指南\"></a>C610电调CAN通信协议及使用指南</h1><h2 id=\"基本信息及资料\"><a href=\"#基本信息及资料\" class=\"headerlink\" title=\"基本信息及资料\"></a>基本信息及资料</h2><ul>\n<li><strong>通信协议</strong>：C610电调采用CAN通信协议</li>\n<li><strong>协议参考文档</strong>：40. CAN—通讯实验 — [野火]STM32 HAL库开发实战指南——基于H743_Pro_V</li>\n<li><strong>硬件适配</strong>：Arduino Mega2560无CAN差分信号引脚，需外接MCP2515（实现CAN差分信号与SPI信号转换）</li>\n<li><strong>推荐库</strong>：<a href=\"https://github.com/autowp/arduino-mcp2515\">GitHub - autowp&#x2F;arduino-mcp2515</a>（Arduino MCP2515 CAN接口库）</li>\n</ul>\n<h2 id=\"报文接收格式\"><a href=\"#报文接收格式\" class=\"headerlink\" title=\"报文接收格式\"></a>报文接收格式</h2><p>用于向电调发送控制指令控制电调的电流输出,两个标识符(0x200和0x1FF)各自对应 控制4个ID的电调。控制转矩电流值范围-10000-0-10000,对应电调输出的转矩电流 范围-10-0-10A。</p>\n<p>即0x200用于控制1-4号电调</p>\n<table>\n<thead>\n<tr>\n<th>数据域</th>\n<th>内容</th>\n<th>电调ID</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>DATA[0]</td>\n<td>控制电流值高8位</td>\n<td>1</td>\n</tr>\n<tr>\n<td>DATA[1]</td>\n<td>控制电流值低8位</td>\n<td>1</td>\n</tr>\n<tr>\n<td>DATA[2]</td>\n<td>控制电流值高8位</td>\n<td>2</td>\n</tr>\n<tr>\n<td>DATA[3]</td>\n<td>控制电流值低8位</td>\n<td>2</td>\n</tr>\n<tr>\n<td>DATA[4]</td>\n<td>控制电流值高8位</td>\n<td>3</td>\n</tr>\n<tr>\n<td>DATA[5]</td>\n<td>控制电流值低8位</td>\n<td>3</td>\n</tr>\n<tr>\n<td>DATA[6]</td>\n<td>控制电流值高8位</td>\n<td>4</td>\n</tr>\n<tr>\n<td>DATA[7]</td>\n<td>控制电流值低8位</td>\n<td>4</td>\n</tr>\n</tbody></table>\n<p>0x1FF用于控制5-8号电调</p>\n<table>\n<thead>\n<tr>\n<th>数据域</th>\n<th>内容</th>\n<th>电调ID</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>DATA[0]</td>\n<td>控制电流值高8位</td>\n<td>5</td>\n</tr>\n<tr>\n<td>DATA[1]</td>\n<td>控制电流值低8位</td>\n<td>5</td>\n</tr>\n<tr>\n<td>DATA[2]</td>\n<td>控制电流值高8位</td>\n<td>6</td>\n</tr>\n<tr>\n<td>DATA[3]</td>\n<td>控制电流值低8位</td>\n<td>6</td>\n</tr>\n<tr>\n<td>DATA[4]</td>\n<td>控制电流值高8位</td>\n<td>7</td>\n</tr>\n<tr>\n<td>DATA[5]</td>\n<td>控制电流值低8位</td>\n<td>7</td>\n</tr>\n<tr>\n<td>DATA[6]</td>\n<td>控制电流值高8位</td>\n<td>8</td>\n</tr>\n<tr>\n<td>DATA[7]</td>\n<td>控制电流值低8位</td>\n<td>8</td>\n</tr>\n</tbody></table>\n<h2 id=\"报文反馈格式\"><a href=\"#报文反馈格式\" class=\"headerlink\" title=\"报文反馈格式\"></a>报文反馈格式</h2><h3 id=\"数据域定义\"><a href=\"#数据域定义\" class=\"headerlink\" title=\"数据域定义\"></a>数据域定义</h3><table>\n<thead>\n<tr>\n<th>数据索引</th>\n<th>内容</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>DATA[0]</td>\n<td>转子机械角度高8位</td>\n</tr>\n<tr>\n<td>DATA[1]</td>\n<td>转子机械角度低8位</td>\n</tr>\n<tr>\n<td>DATA[2]</td>\n<td>转子转速高8位</td>\n</tr>\n<tr>\n<td>DATA[3]</td>\n<td>转子转速低8位</td>\n</tr>\n<tr>\n<td>DATA[4]</td>\n<td>实际输出转矩高8位</td>\n</tr>\n<tr>\n<td>DATA[5]</td>\n<td>实际输出转矩低8位</td>\n</tr>\n<tr>\n<td>DATA[6]</td>\n<td>Null</td>\n</tr>\n<tr>\n<td>DATA[7]</td>\n<td>Null</td>\n</tr>\n</tbody></table>\n<p>接收数据时的CANID若为<code>0x201</code>则为ID为1的电调的数据，以此类推。<br>若是ID为<code>0x1FF+ID</code>则为ID为5-8的电调的数据。</p>\n<h3 id=\"关键参数\"><a href=\"#关键参数\" class=\"headerlink\" title=\"关键参数\"></a>关键参数</h3><ul>\n<li>发送频率：默认1KHz（可通过RoboMaster Assistant软件修改）</li>\n<li>转子机械角度范围：0<del>8191（对应物理角度0</del>360°）</li>\n<li>转子转速单位：rpm（转&#x2F;分钟）</li>\n</ul>\n<h2 id=\"高8位与低8位的理解\"><a href=\"#高8位与低8位的理解\" class=\"headerlink\" title=\"高8位与低8位的理解\"></a>高8位与低8位的理解</h2><p>C610电调中16位数据会拆分为高8位和低8位传输，具体说明如下：</p>\n<ol>\n<li><p><strong>数据拆分逻辑</strong>：<br>16位原始数据（如二进制<code>0011 0000 1100 0100</code>）拆分为：  </p>\n<ul>\n<li>高8位：<code>0011 0000</code>（通过16位数据右移8位获取：<code>原始数据 &gt;&gt; 8</code>）  </li>\n<li>低8位：<code>1100 0100</code>（直接截取原始数据的低8位）</li>\n</ul>\n</li>\n<li><p><strong>赋值方式</strong>：<br>高8位赋值给<code>DATA[n]</code>，低8位赋值给<code>DATA[n+1]</code>（如角度数据中，<code>DATA[0]</code>存高8位，<code>DATA[1]</code>存低8位）</p>\n</li>\n</ol>\n<h2 id=\"CAN数据包解析方法\"><a href=\"#CAN数据包解析方法\" class=\"headerlink\" title=\"CAN数据包解析方法\"></a>CAN数据包解析方法</h2><p>解析接收的CAN数据是拆分过程的逆操作，步骤如下：</p>\n<ol>\n<li>将高8位数据（如<code>DATA[0]</code>）转换为16位变量（自动补高位0，例：<code>0011 0000</code>→<code>0000 0000 0011 0000</code>）；  </li>\n<li>将高8位数据左移8位（例：<code>0000 0000 0011 0000 &lt;&lt; 8</code>→<code>0011 0000 0000 0000</code>）；  </li>\n<li>与低8位数据（如<code>DATA[1]</code>）相加，还原16位原始数据（例：<code>0011 0000 0000 0000 + 1100 0100</code>→<code>0011 0000 1100 0100</code>）；  </li>\n<li>转换为十进制输出即得目标数据。</li>\n</ol>\n<h2 id=\"示例程序\"><a href=\"#示例程序\" class=\"headerlink\" title=\"示例程序\"></a>示例程序</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;SPI.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;mcp2515.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">can_frame</span> canMsg;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">can_frame</span> canMsg1;</span><br><span class=\"line\"><span class=\"function\">MCP2515 <span class=\"title\">mcp2515</span><span class=\"params\">(<span class=\"number\">10</span>)</span></span>;  <span class=\"comment\">// 初始化MCP2515，CS引脚为10</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int16_t</span> current = <span class=\"number\">1000</span>;         <span class=\"comment\">// 设定电流值</span></span><br><span class=\"line\"><span class=\"type\">int16_t</span> result_angle = <span class=\"number\">0</span>;       <span class=\"comment\">// 解析后的角度值</span></span><br><span class=\"line\"><span class=\"type\">int16_t</span> result_torque = <span class=\"number\">0</span>;      <span class=\"comment\">// 解析后的转矩值</span></span><br><span class=\"line\"><span class=\"type\">int16_t</span> result_speed = <span class=\"number\">0</span>;       <span class=\"comment\">// 解析后的转速值</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">setup</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  Serial.<span class=\"built_in\">begin</span>(<span class=\"number\">115200</span>);  <span class=\"comment\">// 初始化串口通信</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 初始化MCP2515</span></span><br><span class=\"line\">  mcp2515.<span class=\"built_in\">reset</span>();</span><br><span class=\"line\">  mcp2515.<span class=\"built_in\">setBitrate</span>(CAN_1000KBPS, MCP_8MHZ);  <span class=\"comment\">// 波特率1000KBPS，时钟8MHz</span></span><br><span class=\"line\">  mcp2515.<span class=\"built_in\">setNormalMode</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 配置发送报文</span></span><br><span class=\"line\">  canMsg1.can_id  = <span class=\"number\">0x200</span>;       <span class=\"comment\">// 报文ID</span></span><br><span class=\"line\">  canMsg1.can_dlc = <span class=\"number\">8</span>;           <span class=\"comment\">// 数据长度8字节</span></span><br><span class=\"line\">  <span class=\"comment\">// 填充数据（高8位与低8位拆分）</span></span><br><span class=\"line\">  canMsg1.data[<span class=\"number\">0</span>] = (current &gt;&gt; <span class=\"number\">8</span>);</span><br><span class=\"line\">  canMsg1.data[<span class=\"number\">1</span>] = current;</span><br><span class=\"line\">  canMsg1.data[<span class=\"number\">2</span>] = (current &gt;&gt; <span class=\"number\">8</span>);</span><br><span class=\"line\">  canMsg1.data[<span class=\"number\">3</span>] = current;</span><br><span class=\"line\">  canMsg1.data[<span class=\"number\">4</span>] = (current &gt;&gt; <span class=\"number\">8</span>);</span><br><span class=\"line\">  canMsg1.data[<span class=\"number\">5</span>] = current;</span><br><span class=\"line\">  canMsg1.data[<span class=\"number\">6</span>] = (current &gt;&gt; <span class=\"number\">8</span>);</span><br><span class=\"line\">  canMsg1.data[<span class=\"number\">7</span>] = current;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">loop</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 发送报文</span></span><br><span class=\"line\">  mcp2515.<span class=\"built_in\">sendMessage</span>(&amp;canMsg1);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 接收并解析报文</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (mcp2515.<span class=\"built_in\">readMessage</span>(&amp;canMsg) == MCP2515::ERROR_OK) &#123;</span><br><span class=\"line\">    Serial.<span class=\"built_in\">print</span>(canMsg.can_id, HEX);  <span class=\"comment\">// 输出CAN ID（十六进制）</span></span><br><span class=\"line\">    Serial.<span class=\"built_in\">print</span>(<span class=\"string\">&quot; &quot;</span>);</span><br><span class=\"line\">    Serial.<span class=\"built_in\">print</span>(canMsg.can_dlc, HEX); <span class=\"comment\">// 输出数据长度（十六进制）</span></span><br><span class=\"line\">    Serial.<span class=\"built_in\">print</span>(<span class=\"string\">&quot; &quot;</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 解析转子转速（高8位左移8位+低8位）</span></span><br><span class=\"line\">    Serial.<span class=\"built_in\">print</span>(<span class=\"string\">&quot;转子转速：&quot;</span>);</span><br><span class=\"line\">    result_speed = ((<span class=\"type\">uint16_t</span>)canMsg.data[<span class=\"number\">2</span>] &lt;&lt; <span class=\"number\">8</span>) + canMsg.data[<span class=\"number\">3</span>];</span><br><span class=\"line\">    Serial.<span class=\"built_in\">print</span>(result_speed / <span class=\"number\">36</span>, DEC);  <span class=\"comment\">// 输出转速（十进制）</span></span><br><span class=\"line\">    Serial.<span class=\"built_in\">print</span>(<span class=\"string\">&quot;; &quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"length":1088,"excerpt":"","more":"<h1 id=\"C610电调CAN通信协议及使用指南\"><a href=\"#C610电调CAN通信协议及使用指南\" class=\"headerlink\" title=\"C610电调CAN通信协议及使用指南\"></a>C610电调CAN通信协议及使用指南</h1><h2 id=\"基本信息及资料\"><a href=\"#基本信息及资料\" class=\"headerlink\" title=\"基本信息及资料\"></a>基本信息及资料</h2><ul>\n<li><strong>通信协议</strong>：C610电调采用CAN通信协议</li>\n<li><strong>协议参考文档</strong>：40. CAN—通讯实验 — [野火]STM32 HAL库开发实战指南——基于H743_Pro_V</li>\n<li><strong>硬件适配</strong>：Arduino Mega2560无CAN差分信号引脚，需外接MCP2515（实现CAN差分信号与SPI信号转换）</li>\n<li><strong>推荐库</strong>：<a href=\"https://github.com/autowp/arduino-mcp2515\">GitHub - autowp&#x2F;arduino-mcp2515</a>（Arduino MCP2515 CAN接口库）</li>\n</ul>\n<h2 id=\"报文接收格式\"><a href=\"#报文接收格式\" class=\"headerlink\" title=\"报文接收格式\"></a>报文接收格式</h2><p>用于向电调发送控制指令控制电调的电流输出,两个标识符(0x200和0x1FF)各自对应 控制4个ID的电调。控制转矩电流值范围-10000-0-10000,对应电调输出的转矩电流 范围-10-0-10A。</p>\n<p>即0x200用于控制1-4号电调</p>\n<table>\n<thead>\n<tr>\n<th>数据域</th>\n<th>内容</th>\n<th>电调ID</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>DATA[0]</td>\n<td>控制电流值高8位</td>\n<td>1</td>\n</tr>\n<tr>\n<td>DATA[1]</td>\n<td>控制电流值低8位</td>\n<td>1</td>\n</tr>\n<tr>\n<td>DATA[2]</td>\n<td>控制电流值高8位</td>\n<td>2</td>\n</tr>\n<tr>\n<td>DATA[3]</td>\n<td>控制电流值低8位</td>\n<td>2</td>\n</tr>\n<tr>\n<td>DATA[4]</td>\n<td>控制电流值高8位</td>\n<td>3</td>\n</tr>\n<tr>\n<td>DATA[5]</td>\n<td>控制电流值低8位</td>\n<td>3</td>\n</tr>\n<tr>\n<td>DATA[6]</td>\n<td>控制电流值高8位</td>\n<td>4</td>\n</tr>\n<tr>\n<td>DATA[7]</td>\n<td>控制电流值低8位</td>\n<td>4</td>\n</tr>\n</tbody></table>\n<p>0x1FF用于控制5-8号电调</p>\n<table>\n<thead>\n<tr>\n<th>数据域</th>\n<th>内容</th>\n<th>电调ID</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>DATA[0]</td>\n<td>控制电流值高8位</td>\n<td>5</td>\n</tr>\n<tr>\n<td>DATA[1]</td>\n<td>控制电流值低8位</td>\n<td>5</td>\n</tr>\n<tr>\n<td>DATA[2]</td>\n<td>控制电流值高8位</td>\n<td>6</td>\n</tr>\n<tr>\n<td>DATA[3]</td>\n<td>控制电流值低8位</td>\n<td>6</td>\n</tr>\n<tr>\n<td>DATA[4]</td>\n<td>控制电流值高8位</td>\n<td>7</td>\n</tr>\n<tr>\n<td>DATA[5]</td>\n<td>控制电流值低8位</td>\n<td>7</td>\n</tr>\n<tr>\n<td>DATA[6]</td>\n<td>控制电流值高8位</td>\n<td>8</td>\n</tr>\n<tr>\n<td>DATA[7]</td>\n<td>控制电流值低8位</td>\n<td>8</td>\n</tr>\n</tbody></table>\n<h2 id=\"报文反馈格式\"><a href=\"#报文反馈格式\" class=\"headerlink\" title=\"报文反馈格式\"></a>报文反馈格式</h2><h3 id=\"数据域定义\"><a href=\"#数据域定义\" class=\"headerlink\" title=\"数据域定义\"></a>数据域定义</h3><table>\n<thead>\n<tr>\n<th>数据索引</th>\n<th>内容</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>DATA[0]</td>\n<td>转子机械角度高8位</td>\n</tr>\n<tr>\n<td>DATA[1]</td>\n<td>转子机械角度低8位</td>\n</tr>\n<tr>\n<td>DATA[2]</td>\n<td>转子转速高8位</td>\n</tr>\n<tr>\n<td>DATA[3]</td>\n<td>转子转速低8位</td>\n</tr>\n<tr>\n<td>DATA[4]</td>\n<td>实际输出转矩高8位</td>\n</tr>\n<tr>\n<td>DATA[5]</td>\n<td>实际输出转矩低8位</td>\n</tr>\n<tr>\n<td>DATA[6]</td>\n<td>Null</td>\n</tr>\n<tr>\n<td>DATA[7]</td>\n<td>Null</td>\n</tr>\n</tbody></table>\n<p>接收数据时的CANID若为<code>0x201</code>则为ID为1的电调的数据，以此类推。<br>若是ID为<code>0x1FF+ID</code>则为ID为5-8的电调的数据。</p>\n<h3 id=\"关键参数\"><a href=\"#关键参数\" class=\"headerlink\" title=\"关键参数\"></a>关键参数</h3><ul>\n<li>发送频率：默认1KHz（可通过RoboMaster Assistant软件修改）</li>\n<li>转子机械角度范围：0<del>8191（对应物理角度0</del>360°）</li>\n<li>转子转速单位：rpm（转&#x2F;分钟）</li>\n</ul>\n<h2 id=\"高8位与低8位的理解\"><a href=\"#高8位与低8位的理解\" class=\"headerlink\" title=\"高8位与低8位的理解\"></a>高8位与低8位的理解</h2><p>C610电调中16位数据会拆分为高8位和低8位传输，具体说明如下：</p>\n<ol>\n<li><p><strong>数据拆分逻辑</strong>：<br>16位原始数据（如二进制<code>0011 0000 1100 0100</code>）拆分为：  </p>\n<ul>\n<li>高8位：<code>0011 0000</code>（通过16位数据右移8位获取：<code>原始数据 &gt;&gt; 8</code>）  </li>\n<li>低8位：<code>1100 0100</code>（直接截取原始数据的低8位）</li>\n</ul>\n</li>\n<li><p><strong>赋值方式</strong>：<br>高8位赋值给<code>DATA[n]</code>，低8位赋值给<code>DATA[n+1]</code>（如角度数据中，<code>DATA[0]</code>存高8位，<code>DATA[1]</code>存低8位）</p>\n</li>\n</ol>\n<h2 id=\"CAN数据包解析方法\"><a href=\"#CAN数据包解析方法\" class=\"headerlink\" title=\"CAN数据包解析方法\"></a>CAN数据包解析方法</h2><p>解析接收的CAN数据是拆分过程的逆操作，步骤如下：</p>\n<ol>\n<li>将高8位数据（如<code>DATA[0]</code>）转换为16位变量（自动补高位0，例：<code>0011 0000</code>→<code>0000 0000 0011 0000</code>）；  </li>\n<li>将高8位数据左移8位（例：<code>0000 0000 0011 0000 &lt;&lt; 8</code>→<code>0011 0000 0000 0000</code>）；  </li>\n<li>与低8位数据（如<code>DATA[1]</code>）相加，还原16位原始数据（例：<code>0011 0000 0000 0000 + 1100 0100</code>→<code>0011 0000 1100 0100</code>）；  </li>\n<li>转换为十进制输出即得目标数据。</li>\n</ol>\n<h2 id=\"示例程序\"><a href=\"#示例程序\" class=\"headerlink\" title=\"示例程序\"></a>示例程序</h2><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;SPI.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;mcp2515.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">can_frame</span> canMsg;</span><br><span class=\"line\"><span class=\"keyword\">struct</span> <span class=\"title class_\">can_frame</span> canMsg1;</span><br><span class=\"line\"><span class=\"function\">MCP2515 <span class=\"title\">mcp2515</span><span class=\"params\">(<span class=\"number\">10</span>)</span></span>;  <span class=\"comment\">// 初始化MCP2515，CS引脚为10</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int16_t</span> current = <span class=\"number\">1000</span>;         <span class=\"comment\">// 设定电流值</span></span><br><span class=\"line\"><span class=\"type\">int16_t</span> result_angle = <span class=\"number\">0</span>;       <span class=\"comment\">// 解析后的角度值</span></span><br><span class=\"line\"><span class=\"type\">int16_t</span> result_torque = <span class=\"number\">0</span>;      <span class=\"comment\">// 解析后的转矩值</span></span><br><span class=\"line\"><span class=\"type\">int16_t</span> result_speed = <span class=\"number\">0</span>;       <span class=\"comment\">// 解析后的转速值</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">setup</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  Serial.<span class=\"built_in\">begin</span>(<span class=\"number\">115200</span>);  <span class=\"comment\">// 初始化串口通信</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 初始化MCP2515</span></span><br><span class=\"line\">  mcp2515.<span class=\"built_in\">reset</span>();</span><br><span class=\"line\">  mcp2515.<span class=\"built_in\">setBitrate</span>(CAN_1000KBPS, MCP_8MHZ);  <span class=\"comment\">// 波特率1000KBPS，时钟8MHz</span></span><br><span class=\"line\">  mcp2515.<span class=\"built_in\">setNormalMode</span>();</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 配置发送报文</span></span><br><span class=\"line\">  canMsg1.can_id  = <span class=\"number\">0x200</span>;       <span class=\"comment\">// 报文ID</span></span><br><span class=\"line\">  canMsg1.can_dlc = <span class=\"number\">8</span>;           <span class=\"comment\">// 数据长度8字节</span></span><br><span class=\"line\">  <span class=\"comment\">// 填充数据（高8位与低8位拆分）</span></span><br><span class=\"line\">  canMsg1.data[<span class=\"number\">0</span>] = (current &gt;&gt; <span class=\"number\">8</span>);</span><br><span class=\"line\">  canMsg1.data[<span class=\"number\">1</span>] = current;</span><br><span class=\"line\">  canMsg1.data[<span class=\"number\">2</span>] = (current &gt;&gt; <span class=\"number\">8</span>);</span><br><span class=\"line\">  canMsg1.data[<span class=\"number\">3</span>] = current;</span><br><span class=\"line\">  canMsg1.data[<span class=\"number\">4</span>] = (current &gt;&gt; <span class=\"number\">8</span>);</span><br><span class=\"line\">  canMsg1.data[<span class=\"number\">5</span>] = current;</span><br><span class=\"line\">  canMsg1.data[<span class=\"number\">6</span>] = (current &gt;&gt; <span class=\"number\">8</span>);</span><br><span class=\"line\">  canMsg1.data[<span class=\"number\">7</span>] = current;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"type\">void</span> <span class=\"title\">loop</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 发送报文</span></span><br><span class=\"line\">  mcp2515.<span class=\"built_in\">sendMessage</span>(&amp;canMsg1);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 接收并解析报文</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (mcp2515.<span class=\"built_in\">readMessage</span>(&amp;canMsg) == MCP2515::ERROR_OK) &#123;</span><br><span class=\"line\">    Serial.<span class=\"built_in\">print</span>(canMsg.can_id, HEX);  <span class=\"comment\">// 输出CAN ID（十六进制）</span></span><br><span class=\"line\">    Serial.<span class=\"built_in\">print</span>(<span class=\"string\">&quot; &quot;</span>);</span><br><span class=\"line\">    Serial.<span class=\"built_in\">print</span>(canMsg.can_dlc, HEX); <span class=\"comment\">// 输出数据长度（十六进制）</span></span><br><span class=\"line\">    Serial.<span class=\"built_in\">print</span>(<span class=\"string\">&quot; &quot;</span>);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 解析转子转速（高8位左移8位+低8位）</span></span><br><span class=\"line\">    Serial.<span class=\"built_in\">print</span>(<span class=\"string\">&quot;转子转速：&quot;</span>);</span><br><span class=\"line\">    result_speed = ((<span class=\"type\">uint16_t</span>)canMsg.data[<span class=\"number\">2</span>] &lt;&lt; <span class=\"number\">8</span>) + canMsg.data[<span class=\"number\">3</span>];</span><br><span class=\"line\">    Serial.<span class=\"built_in\">print</span>(result_speed / <span class=\"number\">36</span>, DEC);  <span class=\"comment\">// 输出转速（十进制）</span></span><br><span class=\"line\">    Serial.<span class=\"built_in\">print</span>(<span class=\"string\">&quot;; &quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"C语言指针到底是个什么东西","date":"2021-04-30T09:48:06.000Z","_content":"# C语言指针到底是个什么东西\n\n指针，恐怕是C语言中最让人又爱又恨的东西。有人觉得它很难懂，但是不得不说，它真的很好用！！！。\n\n\n## 指针是什么？—— 本质是地址\n\n你可以把指针理解为一种特殊的变量类型——没错，`int*`、`char*`本质上都是指针类型。它们的核心功能只有一个：存储内存地址。\n\n先看个最基础的例子：\n\n```c\n#include <stdio.h>\nint main(int argc, char const *argv[])\n{\n    int a = 123;\n    int* pointer = &a;  // 取a的地址，赋值给指针\n    printf(\"a的值: %d\\n\", a);\n    printf(\"pointer存储的地址: %p\\n\", pointer);\n    printf(\"pointer指向的内容: %d\\n\", *pointer);  // *表示\"取地址中的值\"\n    return 0;\n}\n```\n\n运行结果显而易见：\n```\na的值: 123\npointer存储的地址: 0x7ffff91d4d2c  // 每次运行可能不同\npointer指向的内容: 123\n```\n\n这里的`*pointer`就是\"解引用\"——通过指针存储的地址，找到并取出该地址中存放的数据。\n\n\n## 指针的\"无类型\"本质\n\n上面的例子太常规了。要体会到真正的指针，要从\"抛开类型限制\"开始。\n\n看这段略有不同的代码：\n\n```c\n#include <stdio.h>\nint main(int argc, char const *argv[])\n{\n    int a = 123;\n    char* pointer = (char*)&a;  // 这里指针类型变成了char*\n    printf(\"a的值: %d\\n\", a);\n    printf(\"pointer存储的地址: %p\\n\", pointer);\n    printf(\"pointer指向的内容: %d\\n\", *pointer);\n    return 0;\n}\n```\n\n运行结果和之前几乎一样：\n```\na的值: 123\npointer存储的地址: 0x7ffff842f12c  // 地址随机分配，和上次不同很正常\npointer指向的内容: 123\n```\n\n这说明什么？**无论指针声明为`int*`还是`char*`，它本质上都只是存储一个地址**。类型只是告诉编译器：\"我该如何解读这个地址里的数据\"。\n\n如果我们用`%c`输出`*pointer`（把123当ASCII码解析）：\n\n```\n*pointer对应的字符: {\n```\n\n因为`{`的ASCII码正好是123——指针存储的地址没变，只是解读方式变了。\n\n\n## 类型影响什么？—— 指针的偏移量\n\n既然类型不影响指针存储的地址，那不同类型的指针有什么区别？答案是：**加减运算时的偏移量**。\n\n- `char*`指针：加减1，偏移1个字节（因为`char`占1字节）\n- `int*`指针：加减1，偏移4个字节（在32位环境下，`int`通常占4字节）\n\n看这个例子就明白了：\n\n```c\n#include <stdio.h>\nint main(int argc, char const *argv[])\n{\n    // 字符数组：连续存储8个字节\n    char s[8] = {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'};\n    int* pointer = (int*)s;  // 用int*指针指向数组首地址\n    \n    while (*pointer)  // 简单判断（实际应避免用0作为结束符的情况）\n    {\n        printf(\"%c\\n\", *pointer);  // 解读4字节中的第一个字符\n        pointer++;  // 偏移4个字节\n    }\n    return 0;\n}\n```\n\n运行结果：\n```\na  // 指向s[0]\ne  // 偏移4字节后指向s[4]\n```\n\n完全符合预期——`int*`指针每次+1跳过4个字节，正好从第一个字符\"a\"跳到第五个字符\"e\"。\n\n\n## 函数也能被指针指？\n\nC语言中，函数名和数组名一样，本质上都是地址。既然是地址，那普通指针能不能指向函数？\n\n先看个对比：\n\n```c\nvoid function(){}  // 定义一个空函数\n#include <stdio.h>\nint main(int argc, char const *argv[])\n{\n    void (*fp)() = function;  // 标准函数指针\n    int *p = (int *)function;  // 用int*指针指向函数\n    \n    printf(\"函数指针fp的值: %p\\n\", fp);\n    printf(\"普通指针p的值: %p\\n\", p);\n    return 0;\n}\n```\n\n运行结果：\n```\n函数指针fp的值: 0x7f3722b95149\n普通指针p的值: 0x7f3722b95149\n```\n\n两个指针存储的地址完全相同！这说明：**任何指针类型都能存储函数的地址**。\n\n但别急着高兴，我们来个\"骚操作\"：\n\n```c\n#include <stdio.h>\nvoid function()\n{\n    printf(\"Hello Pointer\\n\");\n}\nint main(int argc, char const *argv[])\n{\n    function();  // 正常调用一次\n    \n    int *p = (int *)function;  // 用int*指向函数\n    *p = 0;  // 尝试修改函数所在地址的内容\n    \n    function();  // 再次调用\n    return 0 ;\n}\n```\n\n运行结果：\n```\nHello Pointer\n[1]    1127 segmentation fault (core dumped)  ./demo\n```\n\n程序崩溃了！为什么？\n\n用调试工具查看会发现：函数的机器码存放在只读内存区域（代码段），当我们试图用`*p = 0`修改时，会触发内存保护机制，导致段错误。这也从侧面证明：**指针确实指向了函数的真实地址**，我们没办法强制进行修改。\n\n\n## 指针与数据的\"部分解读\"\n\n指针的类型不仅影响偏移，还决定了\"一次读多少字节\"。比如`short`占2字节，`int`占4字节，当用`short*`指向`int`变量时，会只读取低2字节。\n\n看这个例子：\n\n```c\n#include <stdio.h>\nint main(int argc, char const *argv[])\n{\n    int a = 11 , b = 111111;\n    short* p = (short*)&a;\n    printf(\"a的低2字节: %d\\n\", *p);  // 11在short范围内，正常输出\n    \n    p = (short*)&b;\n    printf(\"b的低2字节: %d\\n\", *p);  // 111111超出short范围，结果\"奇怪\"\n    return 0 ;\n}\n```\n\n运行结果：\n```\na的低2字节: 11\nb的低2字节: -19961\n```\n\n为什么`b`的结果是-19961？这涉及到二进制存储和补码规则。`111111`的二进制超过了2字节（16位），`short*`只读取低16位，而这16位恰好是-19961的补码（感兴趣的话可以自己换算验证）。\n\n\n## 用指针\"解剖\"内存：位域实验\n\n我们可以用指针配合位域，更直观地看内存存储：\n\n```c\n#include <stdio.h>\n// 定义一个16位的位域结构（模拟short）\nstruct num{\n    short a:1,b:1,c:1,d:1,e:1,f:1,g:1,h:1,\n          i:1,j:1,k:1,l:1,m:1,n:1,o:1,p:1;  // 16个1位字段\n};\nint main(int argc, char const *argv[])\n{\n    struct num a;\n    // 前15位设为1，最后1位设为0\n    a.a=a.b=a.c=a.d=a.e=a.f=a.g=a.h=1;\n    a.i=a.j=a.k=a.l=a.m=a.n=a.o=1;\n    a.p=0;\n    \n    short* sp = (short*)&a;  // 用short*读16位\n    printf(\"16位解读: %d\\n\", *sp);  // 0111111111111111 → 32767\n    \n    char* cp = (char*)&a;  // 用char*读低8位\n    printf(\"低8位解读: %d\\n\", *cp);  // 11111111 → -1（补码规则）\n    return 0 ;\n}\n```\n\n运行结果：\n```\n16位解读: 32767\n低8位解读: -1\n```\n\n**指针类型决定了内存的解读方式**——同样的二进制，用16位读是32767，用8位读（且视为有符号数）就是-1。\n\n\n## 指针的\"手动分配\"技巧\n\n理解了指针的本质，我们甚至可以手动指定变量的存储区域。比如给结构体\"分配\"栈上的缓冲区：\n\n```c\n#include <stdio.h>\nstruct a{};  // 空结构体（大小为0，但可以作为指针类型）\nint main(int argc, char const *argv[])\n{\n    char buffer[128];  // 栈上的128字节缓冲区\n    struct a* sa = (struct a*)buffer;  // 让结构体指针指向缓冲区\n    \n    // 之后操作sa，就相当于操作buffer中的内存\n    return 0;\n}\n```\n\n这种技巧在嵌入式开发或需要精确控制内存的场景中很常用。\n\n\n## 总结：指针的核心是\"瞎搞\"的自由\n\nC语言指针的魅力，在于它打破了很多\"规则\"：\n- 类型不限制存储的地址，只影响解读方式\n- 任何指针都能指向任何地址（函数、变量、数组...）\n- 可以手动控制内存的读写范围和方式\n\n当然，这种自由也伴随着风险，但是不得不说这玩意儿确实很好玩。\n","source":"_posts/2021-04-30-C语言指针到底是个什么东西.md","raw":"---\ntitle: C语言指针到底是个什么东西\ndate: 2021-04-30 17:48:06\ntags:\n---\n# C语言指针到底是个什么东西\n\n指针，恐怕是C语言中最让人又爱又恨的东西。有人觉得它很难懂，但是不得不说，它真的很好用！！！。\n\n\n## 指针是什么？—— 本质是地址\n\n你可以把指针理解为一种特殊的变量类型——没错，`int*`、`char*`本质上都是指针类型。它们的核心功能只有一个：存储内存地址。\n\n先看个最基础的例子：\n\n```c\n#include <stdio.h>\nint main(int argc, char const *argv[])\n{\n    int a = 123;\n    int* pointer = &a;  // 取a的地址，赋值给指针\n    printf(\"a的值: %d\\n\", a);\n    printf(\"pointer存储的地址: %p\\n\", pointer);\n    printf(\"pointer指向的内容: %d\\n\", *pointer);  // *表示\"取地址中的值\"\n    return 0;\n}\n```\n\n运行结果显而易见：\n```\na的值: 123\npointer存储的地址: 0x7ffff91d4d2c  // 每次运行可能不同\npointer指向的内容: 123\n```\n\n这里的`*pointer`就是\"解引用\"——通过指针存储的地址，找到并取出该地址中存放的数据。\n\n\n## 指针的\"无类型\"本质\n\n上面的例子太常规了。要体会到真正的指针，要从\"抛开类型限制\"开始。\n\n看这段略有不同的代码：\n\n```c\n#include <stdio.h>\nint main(int argc, char const *argv[])\n{\n    int a = 123;\n    char* pointer = (char*)&a;  // 这里指针类型变成了char*\n    printf(\"a的值: %d\\n\", a);\n    printf(\"pointer存储的地址: %p\\n\", pointer);\n    printf(\"pointer指向的内容: %d\\n\", *pointer);\n    return 0;\n}\n```\n\n运行结果和之前几乎一样：\n```\na的值: 123\npointer存储的地址: 0x7ffff842f12c  // 地址随机分配，和上次不同很正常\npointer指向的内容: 123\n```\n\n这说明什么？**无论指针声明为`int*`还是`char*`，它本质上都只是存储一个地址**。类型只是告诉编译器：\"我该如何解读这个地址里的数据\"。\n\n如果我们用`%c`输出`*pointer`（把123当ASCII码解析）：\n\n```\n*pointer对应的字符: {\n```\n\n因为`{`的ASCII码正好是123——指针存储的地址没变，只是解读方式变了。\n\n\n## 类型影响什么？—— 指针的偏移量\n\n既然类型不影响指针存储的地址，那不同类型的指针有什么区别？答案是：**加减运算时的偏移量**。\n\n- `char*`指针：加减1，偏移1个字节（因为`char`占1字节）\n- `int*`指针：加减1，偏移4个字节（在32位环境下，`int`通常占4字节）\n\n看这个例子就明白了：\n\n```c\n#include <stdio.h>\nint main(int argc, char const *argv[])\n{\n    // 字符数组：连续存储8个字节\n    char s[8] = {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'};\n    int* pointer = (int*)s;  // 用int*指针指向数组首地址\n    \n    while (*pointer)  // 简单判断（实际应避免用0作为结束符的情况）\n    {\n        printf(\"%c\\n\", *pointer);  // 解读4字节中的第一个字符\n        pointer++;  // 偏移4个字节\n    }\n    return 0;\n}\n```\n\n运行结果：\n```\na  // 指向s[0]\ne  // 偏移4字节后指向s[4]\n```\n\n完全符合预期——`int*`指针每次+1跳过4个字节，正好从第一个字符\"a\"跳到第五个字符\"e\"。\n\n\n## 函数也能被指针指？\n\nC语言中，函数名和数组名一样，本质上都是地址。既然是地址，那普通指针能不能指向函数？\n\n先看个对比：\n\n```c\nvoid function(){}  // 定义一个空函数\n#include <stdio.h>\nint main(int argc, char const *argv[])\n{\n    void (*fp)() = function;  // 标准函数指针\n    int *p = (int *)function;  // 用int*指针指向函数\n    \n    printf(\"函数指针fp的值: %p\\n\", fp);\n    printf(\"普通指针p的值: %p\\n\", p);\n    return 0;\n}\n```\n\n运行结果：\n```\n函数指针fp的值: 0x7f3722b95149\n普通指针p的值: 0x7f3722b95149\n```\n\n两个指针存储的地址完全相同！这说明：**任何指针类型都能存储函数的地址**。\n\n但别急着高兴，我们来个\"骚操作\"：\n\n```c\n#include <stdio.h>\nvoid function()\n{\n    printf(\"Hello Pointer\\n\");\n}\nint main(int argc, char const *argv[])\n{\n    function();  // 正常调用一次\n    \n    int *p = (int *)function;  // 用int*指向函数\n    *p = 0;  // 尝试修改函数所在地址的内容\n    \n    function();  // 再次调用\n    return 0 ;\n}\n```\n\n运行结果：\n```\nHello Pointer\n[1]    1127 segmentation fault (core dumped)  ./demo\n```\n\n程序崩溃了！为什么？\n\n用调试工具查看会发现：函数的机器码存放在只读内存区域（代码段），当我们试图用`*p = 0`修改时，会触发内存保护机制，导致段错误。这也从侧面证明：**指针确实指向了函数的真实地址**，我们没办法强制进行修改。\n\n\n## 指针与数据的\"部分解读\"\n\n指针的类型不仅影响偏移，还决定了\"一次读多少字节\"。比如`short`占2字节，`int`占4字节，当用`short*`指向`int`变量时，会只读取低2字节。\n\n看这个例子：\n\n```c\n#include <stdio.h>\nint main(int argc, char const *argv[])\n{\n    int a = 11 , b = 111111;\n    short* p = (short*)&a;\n    printf(\"a的低2字节: %d\\n\", *p);  // 11在short范围内，正常输出\n    \n    p = (short*)&b;\n    printf(\"b的低2字节: %d\\n\", *p);  // 111111超出short范围，结果\"奇怪\"\n    return 0 ;\n}\n```\n\n运行结果：\n```\na的低2字节: 11\nb的低2字节: -19961\n```\n\n为什么`b`的结果是-19961？这涉及到二进制存储和补码规则。`111111`的二进制超过了2字节（16位），`short*`只读取低16位，而这16位恰好是-19961的补码（感兴趣的话可以自己换算验证）。\n\n\n## 用指针\"解剖\"内存：位域实验\n\n我们可以用指针配合位域，更直观地看内存存储：\n\n```c\n#include <stdio.h>\n// 定义一个16位的位域结构（模拟short）\nstruct num{\n    short a:1,b:1,c:1,d:1,e:1,f:1,g:1,h:1,\n          i:1,j:1,k:1,l:1,m:1,n:1,o:1,p:1;  // 16个1位字段\n};\nint main(int argc, char const *argv[])\n{\n    struct num a;\n    // 前15位设为1，最后1位设为0\n    a.a=a.b=a.c=a.d=a.e=a.f=a.g=a.h=1;\n    a.i=a.j=a.k=a.l=a.m=a.n=a.o=1;\n    a.p=0;\n    \n    short* sp = (short*)&a;  // 用short*读16位\n    printf(\"16位解读: %d\\n\", *sp);  // 0111111111111111 → 32767\n    \n    char* cp = (char*)&a;  // 用char*读低8位\n    printf(\"低8位解读: %d\\n\", *cp);  // 11111111 → -1（补码规则）\n    return 0 ;\n}\n```\n\n运行结果：\n```\n16位解读: 32767\n低8位解读: -1\n```\n\n**指针类型决定了内存的解读方式**——同样的二进制，用16位读是32767，用8位读（且视为有符号数）就是-1。\n\n\n## 指针的\"手动分配\"技巧\n\n理解了指针的本质，我们甚至可以手动指定变量的存储区域。比如给结构体\"分配\"栈上的缓冲区：\n\n```c\n#include <stdio.h>\nstruct a{};  // 空结构体（大小为0，但可以作为指针类型）\nint main(int argc, char const *argv[])\n{\n    char buffer[128];  // 栈上的128字节缓冲区\n    struct a* sa = (struct a*)buffer;  // 让结构体指针指向缓冲区\n    \n    // 之后操作sa，就相当于操作buffer中的内存\n    return 0;\n}\n```\n\n这种技巧在嵌入式开发或需要精确控制内存的场景中很常用。\n\n\n## 总结：指针的核心是\"瞎搞\"的自由\n\nC语言指针的魅力，在于它打破了很多\"规则\"：\n- 类型不限制存储的地址，只影响解读方式\n- 任何指针都能指向任何地址（函数、变量、数组...）\n- 可以手动控制内存的读写范围和方式\n\n当然，这种自由也伴随着风险，但是不得不说这玩意儿确实很好玩。\n","slug":"C语言指针到底是个什么东西","published":1,"updated":"2025-08-01T09:54:49.775Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmdsndzk5000090li8bs9axfc","content":"<h1 id=\"C语言指针到底是个什么东西\"><a href=\"#C语言指针到底是个什么东西\" class=\"headerlink\" title=\"C语言指针到底是个什么东西\"></a>C语言指针到底是个什么东西</h1><p>指针，恐怕是C语言中最让人又爱又恨的东西。有人觉得它很难懂，但是不得不说，它真的很好用！！！。</p>\n<h2 id=\"指针是什么？——-本质是地址\"><a href=\"#指针是什么？——-本质是地址\" class=\"headerlink\" title=\"指针是什么？—— 本质是地址\"></a>指针是什么？—— 本质是地址</h2><p>你可以把指针理解为一种特殊的变量类型——没错，<code>int*</code>、<code>char*</code>本质上都是指针类型。它们的核心功能只有一个：存储内存地址。</p>\n<p>先看个最基础的例子：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span> <span class=\"type\">const</span> *argv[])</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> a = <span class=\"number\">123</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span>* pointer = &amp;a;  <span class=\"comment\">// 取a的地址，赋值给指针</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;a的值: %d\\n&quot;</span>, a);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;pointer存储的地址: %p\\n&quot;</span>, pointer);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;pointer指向的内容: %d\\n&quot;</span>, *pointer);  <span class=\"comment\">// *表示&quot;取地址中的值&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>运行结果显而易见：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a的值: 123</span><br><span class=\"line\">pointer存储的地址: 0x7ffff91d4d2c  // 每次运行可能不同</span><br><span class=\"line\">pointer指向的内容: 123</span><br></pre></td></tr></table></figure>\n\n<p>这里的<code>*pointer</code>就是”解引用”——通过指针存储的地址，找到并取出该地址中存放的数据。</p>\n<h2 id=\"指针的”无类型”本质\"><a href=\"#指针的”无类型”本质\" class=\"headerlink\" title=\"指针的”无类型”本质\"></a>指针的”无类型”本质</h2><p>上面的例子太常规了。要体会到真正的指针，要从”抛开类型限制”开始。</p>\n<p>看这段略有不同的代码：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span> <span class=\"type\">const</span> *argv[])</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> a = <span class=\"number\">123</span>;</span><br><span class=\"line\">    <span class=\"type\">char</span>* pointer = (<span class=\"type\">char</span>*)&amp;a;  <span class=\"comment\">// 这里指针类型变成了char*</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;a的值: %d\\n&quot;</span>, a);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;pointer存储的地址: %p\\n&quot;</span>, pointer);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;pointer指向的内容: %d\\n&quot;</span>, *pointer);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>运行结果和之前几乎一样：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a的值: 123</span><br><span class=\"line\">pointer存储的地址: 0x7ffff842f12c  // 地址随机分配，和上次不同很正常</span><br><span class=\"line\">pointer指向的内容: 123</span><br></pre></td></tr></table></figure>\n\n<p>这说明什么？<strong>无论指针声明为<code>int*</code>还是<code>char*</code>，它本质上都只是存储一个地址</strong>。类型只是告诉编译器：”我该如何解读这个地址里的数据”。</p>\n<p>如果我们用<code>%c</code>输出<code>*pointer</code>（把123当ASCII码解析）：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*pointer对应的字符: &#123;</span><br></pre></td></tr></table></figure>\n\n<p>因为<code>&#123;</code>的ASCII码正好是123——指针存储的地址没变，只是解读方式变了。</p>\n<h2 id=\"类型影响什么？——-指针的偏移量\"><a href=\"#类型影响什么？——-指针的偏移量\" class=\"headerlink\" title=\"类型影响什么？—— 指针的偏移量\"></a>类型影响什么？—— 指针的偏移量</h2><p>既然类型不影响指针存储的地址，那不同类型的指针有什么区别？答案是：<strong>加减运算时的偏移量</strong>。</p>\n<ul>\n<li><code>char*</code>指针：加减1，偏移1个字节（因为<code>char</code>占1字节）</li>\n<li><code>int*</code>指针：加减1，偏移4个字节（在32位环境下，<code>int</code>通常占4字节）</li>\n</ul>\n<p>看这个例子就明白了：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span> <span class=\"type\">const</span> *argv[])</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 字符数组：连续存储8个字节</span></span><br><span class=\"line\">    <span class=\"type\">char</span> s[<span class=\"number\">8</span>] = &#123;<span class=\"string\">&#x27;a&#x27;</span>, <span class=\"string\">&#x27;b&#x27;</span>, <span class=\"string\">&#x27;c&#x27;</span>, <span class=\"string\">&#x27;d&#x27;</span>, <span class=\"string\">&#x27;e&#x27;</span>, <span class=\"string\">&#x27;f&#x27;</span>, <span class=\"string\">&#x27;g&#x27;</span>, <span class=\"string\">&#x27;h&#x27;</span>&#125;;</span><br><span class=\"line\">    <span class=\"type\">int</span>* pointer = (<span class=\"type\">int</span>*)s;  <span class=\"comment\">// 用int*指针指向数组首地址</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">while</span> (*pointer)  <span class=\"comment\">// 简单判断（实际应避免用0作为结束符的情况）</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%c\\n&quot;</span>, *pointer);  <span class=\"comment\">// 解读4字节中的第一个字符</span></span><br><span class=\"line\">        pointer++;  <span class=\"comment\">// 偏移4个字节</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>运行结果：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a  // 指向s[0]</span><br><span class=\"line\">e  // 偏移4字节后指向s[4]</span><br></pre></td></tr></table></figure>\n\n<p>完全符合预期——<code>int*</code>指针每次+1跳过4个字节，正好从第一个字符”a”跳到第五个字符”e”。</p>\n<h2 id=\"函数也能被指针指？\"><a href=\"#函数也能被指针指？\" class=\"headerlink\" title=\"函数也能被指针指？\"></a>函数也能被指针指？</h2><p>C语言中，函数名和数组名一样，本质上都是地址。既然是地址，那普通指针能不能指向函数？</p>\n<p>先看个对比：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">function</span><span class=\"params\">()</span>&#123;&#125;  <span class=\"comment\">// 定义一个空函数</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span> <span class=\"type\">const</span> *argv[])</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">void</span> (*fp)() = function;  <span class=\"comment\">// 标准函数指针</span></span><br><span class=\"line\">    <span class=\"type\">int</span> *p = (<span class=\"type\">int</span> *)function;  <span class=\"comment\">// 用int*指针指向函数</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;函数指针fp的值: %p\\n&quot;</span>, fp);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;普通指针p的值: %p\\n&quot;</span>, p);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>运行结果：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">函数指针fp的值: 0x7f3722b95149</span><br><span class=\"line\">普通指针p的值: 0x7f3722b95149</span><br></pre></td></tr></table></figure>\n\n<p>两个指针存储的地址完全相同！这说明：<strong>任何指针类型都能存储函数的地址</strong>。</p>\n<p>但别急着高兴，我们来个”骚操作”：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">function</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Hello Pointer\\n&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span> <span class=\"type\">const</span> *argv[])</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    function();  <span class=\"comment\">// 正常调用一次</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"type\">int</span> *p = (<span class=\"type\">int</span> *)function;  <span class=\"comment\">// 用int*指向函数</span></span><br><span class=\"line\">    *p = <span class=\"number\">0</span>;  <span class=\"comment\">// 尝试修改函数所在地址的内容</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    function();  <span class=\"comment\">// 再次调用</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span> ;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>运行结果：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Hello Pointer</span><br><span class=\"line\">[1]    1127 segmentation fault (core dumped)  ./demo</span><br></pre></td></tr></table></figure>\n\n<p>程序崩溃了！为什么？</p>\n<p>用调试工具查看会发现：函数的机器码存放在只读内存区域（代码段），当我们试图用<code>*p = 0</code>修改时，会触发内存保护机制，导致段错误。这也从侧面证明：<strong>指针确实指向了函数的真实地址</strong>，我们没办法强制进行修改。</p>\n<h2 id=\"指针与数据的”部分解读”\"><a href=\"#指针与数据的”部分解读”\" class=\"headerlink\" title=\"指针与数据的”部分解读”\"></a>指针与数据的”部分解读”</h2><p>指针的类型不仅影响偏移，还决定了”一次读多少字节”。比如<code>short</code>占2字节，<code>int</code>占4字节，当用<code>short*</code>指向<code>int</code>变量时，会只读取低2字节。</p>\n<p>看这个例子：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span> <span class=\"type\">const</span> *argv[])</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> a = <span class=\"number\">11</span> , b = <span class=\"number\">111111</span>;</span><br><span class=\"line\">    <span class=\"type\">short</span>* p = (<span class=\"type\">short</span>*)&amp;a;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;a的低2字节: %d\\n&quot;</span>, *p);  <span class=\"comment\">// 11在short范围内，正常输出</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    p = (<span class=\"type\">short</span>*)&amp;b;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;b的低2字节: %d\\n&quot;</span>, *p);  <span class=\"comment\">// 111111超出short范围，结果&quot;奇怪&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span> ;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>运行结果：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a的低2字节: 11</span><br><span class=\"line\">b的低2字节: -19961</span><br></pre></td></tr></table></figure>\n\n<p>为什么<code>b</code>的结果是-19961？这涉及到二进制存储和补码规则。<code>111111</code>的二进制超过了2字节（16位），<code>short*</code>只读取低16位，而这16位恰好是-19961的补码（感兴趣的话可以自己换算验证）。</p>\n<h2 id=\"用指针”解剖”内存：位域实验\"><a href=\"#用指针”解剖”内存：位域实验\" class=\"headerlink\" title=\"用指针”解剖”内存：位域实验\"></a>用指针”解剖”内存：位域实验</h2><p>我们可以用指针配合位域，更直观地看内存存储：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">// 定义一个16位的位域结构（模拟short）</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">num</span>&#123;</span></span><br><span class=\"line\">    <span class=\"type\">short</span> a:<span class=\"number\">1</span>,b:<span class=\"number\">1</span>,c:<span class=\"number\">1</span>,d:<span class=\"number\">1</span>,e:<span class=\"number\">1</span>,f:<span class=\"number\">1</span>,g:<span class=\"number\">1</span>,h:<span class=\"number\">1</span>,</span><br><span class=\"line\">          i:<span class=\"number\">1</span>,j:<span class=\"number\">1</span>,k:<span class=\"number\">1</span>,l:<span class=\"number\">1</span>,m:<span class=\"number\">1</span>,n:<span class=\"number\">1</span>,o:<span class=\"number\">1</span>,p:<span class=\"number\">1</span>;  <span class=\"comment\">// 16个1位字段</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span> <span class=\"type\">const</span> *argv[])</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">num</span> <span class=\"title\">a</span>;</span></span><br><span class=\"line\">    <span class=\"comment\">// 前15位设为1，最后1位设为0</span></span><br><span class=\"line\">    a.a=a.b=a.c=a.d=a.e=a.f=a.g=a.h=<span class=\"number\">1</span>;</span><br><span class=\"line\">    a.i=a.j=a.k=a.l=a.m=a.n=a.o=<span class=\"number\">1</span>;</span><br><span class=\"line\">    a.p=<span class=\"number\">0</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"type\">short</span>* sp = (<span class=\"type\">short</span>*)&amp;a;  <span class=\"comment\">// 用short*读16位</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;16位解读: %d\\n&quot;</span>, *sp);  <span class=\"comment\">// 0111111111111111 → 32767</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"type\">char</span>* cp = (<span class=\"type\">char</span>*)&amp;a;  <span class=\"comment\">// 用char*读低8位</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;低8位解读: %d\\n&quot;</span>, *cp);  <span class=\"comment\">// 11111111 → -1（补码规则）</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span> ;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>运行结果：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">16位解读: 32767</span><br><span class=\"line\">低8位解读: -1</span><br></pre></td></tr></table></figure>\n\n<p><strong>指针类型决定了内存的解读方式</strong>——同样的二进制，用16位读是32767，用8位读（且视为有符号数）就是-1。</p>\n<h2 id=\"指针的”手动分配”技巧\"><a href=\"#指针的”手动分配”技巧\" class=\"headerlink\" title=\"指针的”手动分配”技巧\"></a>指针的”手动分配”技巧</h2><p>理解了指针的本质，我们甚至可以手动指定变量的存储区域。比如给结构体”分配”栈上的缓冲区：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">a</span>&#123;</span>&#125;;  <span class=\"comment\">// 空结构体（大小为0，但可以作为指针类型）</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span> <span class=\"type\">const</span> *argv[])</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">char</span> buffer[<span class=\"number\">128</span>];  <span class=\"comment\">// 栈上的128字节缓冲区</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">a</span>* <span class=\"title\">sa</span> =</span> (<span class=\"keyword\">struct</span> a*)buffer;  <span class=\"comment\">// 让结构体指针指向缓冲区</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 之后操作sa，就相当于操作buffer中的内存</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这种技巧在嵌入式开发或需要精确控制内存的场景中很常用。</p>\n<h2 id=\"总结：指针的核心是”瞎搞”的自由\"><a href=\"#总结：指针的核心是”瞎搞”的自由\" class=\"headerlink\" title=\"总结：指针的核心是”瞎搞”的自由\"></a>总结：指针的核心是”瞎搞”的自由</h2><p>C语言指针的魅力，在于它打破了很多”规则”：</p>\n<ul>\n<li>类型不限制存储的地址，只影响解读方式</li>\n<li>任何指针都能指向任何地址（函数、变量、数组…）</li>\n<li>可以手动控制内存的读写范围和方式</li>\n</ul>\n<p>当然，这种自由也伴随着风险，但是不得不说这玩意儿确实很好玩。</p>\n","site":{"data":{}},"length":1791,"excerpt":"","more":"<h1 id=\"C语言指针到底是个什么东西\"><a href=\"#C语言指针到底是个什么东西\" class=\"headerlink\" title=\"C语言指针到底是个什么东西\"></a>C语言指针到底是个什么东西</h1><p>指针，恐怕是C语言中最让人又爱又恨的东西。有人觉得它很难懂，但是不得不说，它真的很好用！！！。</p>\n<h2 id=\"指针是什么？——-本质是地址\"><a href=\"#指针是什么？——-本质是地址\" class=\"headerlink\" title=\"指针是什么？—— 本质是地址\"></a>指针是什么？—— 本质是地址</h2><p>你可以把指针理解为一种特殊的变量类型——没错，<code>int*</code>、<code>char*</code>本质上都是指针类型。它们的核心功能只有一个：存储内存地址。</p>\n<p>先看个最基础的例子：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span> <span class=\"type\">const</span> *argv[])</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> a = <span class=\"number\">123</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span>* pointer = &amp;a;  <span class=\"comment\">// 取a的地址，赋值给指针</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;a的值: %d\\n&quot;</span>, a);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;pointer存储的地址: %p\\n&quot;</span>, pointer);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;pointer指向的内容: %d\\n&quot;</span>, *pointer);  <span class=\"comment\">// *表示&quot;取地址中的值&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>运行结果显而易见：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a的值: 123</span><br><span class=\"line\">pointer存储的地址: 0x7ffff91d4d2c  // 每次运行可能不同</span><br><span class=\"line\">pointer指向的内容: 123</span><br></pre></td></tr></table></figure>\n\n<p>这里的<code>*pointer</code>就是”解引用”——通过指针存储的地址，找到并取出该地址中存放的数据。</p>\n<h2 id=\"指针的”无类型”本质\"><a href=\"#指针的”无类型”本质\" class=\"headerlink\" title=\"指针的”无类型”本质\"></a>指针的”无类型”本质</h2><p>上面的例子太常规了。要体会到真正的指针，要从”抛开类型限制”开始。</p>\n<p>看这段略有不同的代码：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span> <span class=\"type\">const</span> *argv[])</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> a = <span class=\"number\">123</span>;</span><br><span class=\"line\">    <span class=\"type\">char</span>* pointer = (<span class=\"type\">char</span>*)&amp;a;  <span class=\"comment\">// 这里指针类型变成了char*</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;a的值: %d\\n&quot;</span>, a);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;pointer存储的地址: %p\\n&quot;</span>, pointer);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;pointer指向的内容: %d\\n&quot;</span>, *pointer);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>运行结果和之前几乎一样：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a的值: 123</span><br><span class=\"line\">pointer存储的地址: 0x7ffff842f12c  // 地址随机分配，和上次不同很正常</span><br><span class=\"line\">pointer指向的内容: 123</span><br></pre></td></tr></table></figure>\n\n<p>这说明什么？<strong>无论指针声明为<code>int*</code>还是<code>char*</code>，它本质上都只是存储一个地址</strong>。类型只是告诉编译器：”我该如何解读这个地址里的数据”。</p>\n<p>如果我们用<code>%c</code>输出<code>*pointer</code>（把123当ASCII码解析）：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*pointer对应的字符: &#123;</span><br></pre></td></tr></table></figure>\n\n<p>因为<code>&#123;</code>的ASCII码正好是123——指针存储的地址没变，只是解读方式变了。</p>\n<h2 id=\"类型影响什么？——-指针的偏移量\"><a href=\"#类型影响什么？——-指针的偏移量\" class=\"headerlink\" title=\"类型影响什么？—— 指针的偏移量\"></a>类型影响什么？—— 指针的偏移量</h2><p>既然类型不影响指针存储的地址，那不同类型的指针有什么区别？答案是：<strong>加减运算时的偏移量</strong>。</p>\n<ul>\n<li><code>char*</code>指针：加减1，偏移1个字节（因为<code>char</code>占1字节）</li>\n<li><code>int*</code>指针：加减1，偏移4个字节（在32位环境下，<code>int</code>通常占4字节）</li>\n</ul>\n<p>看这个例子就明白了：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span> <span class=\"type\">const</span> *argv[])</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 字符数组：连续存储8个字节</span></span><br><span class=\"line\">    <span class=\"type\">char</span> s[<span class=\"number\">8</span>] = &#123;<span class=\"string\">&#x27;a&#x27;</span>, <span class=\"string\">&#x27;b&#x27;</span>, <span class=\"string\">&#x27;c&#x27;</span>, <span class=\"string\">&#x27;d&#x27;</span>, <span class=\"string\">&#x27;e&#x27;</span>, <span class=\"string\">&#x27;f&#x27;</span>, <span class=\"string\">&#x27;g&#x27;</span>, <span class=\"string\">&#x27;h&#x27;</span>&#125;;</span><br><span class=\"line\">    <span class=\"type\">int</span>* pointer = (<span class=\"type\">int</span>*)s;  <span class=\"comment\">// 用int*指针指向数组首地址</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">while</span> (*pointer)  <span class=\"comment\">// 简单判断（实际应避免用0作为结束符的情况）</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%c\\n&quot;</span>, *pointer);  <span class=\"comment\">// 解读4字节中的第一个字符</span></span><br><span class=\"line\">        pointer++;  <span class=\"comment\">// 偏移4个字节</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>运行结果：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a  // 指向s[0]</span><br><span class=\"line\">e  // 偏移4字节后指向s[4]</span><br></pre></td></tr></table></figure>\n\n<p>完全符合预期——<code>int*</code>指针每次+1跳过4个字节，正好从第一个字符”a”跳到第五个字符”e”。</p>\n<h2 id=\"函数也能被指针指？\"><a href=\"#函数也能被指针指？\" class=\"headerlink\" title=\"函数也能被指针指？\"></a>函数也能被指针指？</h2><p>C语言中，函数名和数组名一样，本质上都是地址。既然是地址，那普通指针能不能指向函数？</p>\n<p>先看个对比：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">function</span><span class=\"params\">()</span>&#123;&#125;  <span class=\"comment\">// 定义一个空函数</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span> <span class=\"type\">const</span> *argv[])</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">void</span> (*fp)() = function;  <span class=\"comment\">// 标准函数指针</span></span><br><span class=\"line\">    <span class=\"type\">int</span> *p = (<span class=\"type\">int</span> *)function;  <span class=\"comment\">// 用int*指针指向函数</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;函数指针fp的值: %p\\n&quot;</span>, fp);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;普通指针p的值: %p\\n&quot;</span>, p);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>运行结果：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">函数指针fp的值: 0x7f3722b95149</span><br><span class=\"line\">普通指针p的值: 0x7f3722b95149</span><br></pre></td></tr></table></figure>\n\n<p>两个指针存储的地址完全相同！这说明：<strong>任何指针类型都能存储函数的地址</strong>。</p>\n<p>但别急着高兴，我们来个”骚操作”：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">function</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Hello Pointer\\n&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span> <span class=\"type\">const</span> *argv[])</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    function();  <span class=\"comment\">// 正常调用一次</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"type\">int</span> *p = (<span class=\"type\">int</span> *)function;  <span class=\"comment\">// 用int*指向函数</span></span><br><span class=\"line\">    *p = <span class=\"number\">0</span>;  <span class=\"comment\">// 尝试修改函数所在地址的内容</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    function();  <span class=\"comment\">// 再次调用</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span> ;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>运行结果：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Hello Pointer</span><br><span class=\"line\">[1]    1127 segmentation fault (core dumped)  ./demo</span><br></pre></td></tr></table></figure>\n\n<p>程序崩溃了！为什么？</p>\n<p>用调试工具查看会发现：函数的机器码存放在只读内存区域（代码段），当我们试图用<code>*p = 0</code>修改时，会触发内存保护机制，导致段错误。这也从侧面证明：<strong>指针确实指向了函数的真实地址</strong>，我们没办法强制进行修改。</p>\n<h2 id=\"指针与数据的”部分解读”\"><a href=\"#指针与数据的”部分解读”\" class=\"headerlink\" title=\"指针与数据的”部分解读”\"></a>指针与数据的”部分解读”</h2><p>指针的类型不仅影响偏移，还决定了”一次读多少字节”。比如<code>short</code>占2字节，<code>int</code>占4字节，当用<code>short*</code>指向<code>int</code>变量时，会只读取低2字节。</p>\n<p>看这个例子：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span> <span class=\"type\">const</span> *argv[])</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">int</span> a = <span class=\"number\">11</span> , b = <span class=\"number\">111111</span>;</span><br><span class=\"line\">    <span class=\"type\">short</span>* p = (<span class=\"type\">short</span>*)&amp;a;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;a的低2字节: %d\\n&quot;</span>, *p);  <span class=\"comment\">// 11在short范围内，正常输出</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    p = (<span class=\"type\">short</span>*)&amp;b;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;b的低2字节: %d\\n&quot;</span>, *p);  <span class=\"comment\">// 111111超出short范围，结果&quot;奇怪&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span> ;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>运行结果：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a的低2字节: 11</span><br><span class=\"line\">b的低2字节: -19961</span><br></pre></td></tr></table></figure>\n\n<p>为什么<code>b</code>的结果是-19961？这涉及到二进制存储和补码规则。<code>111111</code>的二进制超过了2字节（16位），<code>short*</code>只读取低16位，而这16位恰好是-19961的补码（感兴趣的话可以自己换算验证）。</p>\n<h2 id=\"用指针”解剖”内存：位域实验\"><a href=\"#用指针”解剖”内存：位域实验\" class=\"headerlink\" title=\"用指针”解剖”内存：位域实验\"></a>用指针”解剖”内存：位域实验</h2><p>我们可以用指针配合位域，更直观地看内存存储：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"comment\">// 定义一个16位的位域结构（模拟short）</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">num</span>&#123;</span></span><br><span class=\"line\">    <span class=\"type\">short</span> a:<span class=\"number\">1</span>,b:<span class=\"number\">1</span>,c:<span class=\"number\">1</span>,d:<span class=\"number\">1</span>,e:<span class=\"number\">1</span>,f:<span class=\"number\">1</span>,g:<span class=\"number\">1</span>,h:<span class=\"number\">1</span>,</span><br><span class=\"line\">          i:<span class=\"number\">1</span>,j:<span class=\"number\">1</span>,k:<span class=\"number\">1</span>,l:<span class=\"number\">1</span>,m:<span class=\"number\">1</span>,n:<span class=\"number\">1</span>,o:<span class=\"number\">1</span>,p:<span class=\"number\">1</span>;  <span class=\"comment\">// 16个1位字段</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span> <span class=\"type\">const</span> *argv[])</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">num</span> <span class=\"title\">a</span>;</span></span><br><span class=\"line\">    <span class=\"comment\">// 前15位设为1，最后1位设为0</span></span><br><span class=\"line\">    a.a=a.b=a.c=a.d=a.e=a.f=a.g=a.h=<span class=\"number\">1</span>;</span><br><span class=\"line\">    a.i=a.j=a.k=a.l=a.m=a.n=a.o=<span class=\"number\">1</span>;</span><br><span class=\"line\">    a.p=<span class=\"number\">0</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"type\">short</span>* sp = (<span class=\"type\">short</span>*)&amp;a;  <span class=\"comment\">// 用short*读16位</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;16位解读: %d\\n&quot;</span>, *sp);  <span class=\"comment\">// 0111111111111111 → 32767</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"type\">char</span>* cp = (<span class=\"type\">char</span>*)&amp;a;  <span class=\"comment\">// 用char*读低8位</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;低8位解读: %d\\n&quot;</span>, *cp);  <span class=\"comment\">// 11111111 → -1（补码规则）</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span> ;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>运行结果：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">16位解读: 32767</span><br><span class=\"line\">低8位解读: -1</span><br></pre></td></tr></table></figure>\n\n<p><strong>指针类型决定了内存的解读方式</strong>——同样的二进制，用16位读是32767，用8位读（且视为有符号数）就是-1。</p>\n<h2 id=\"指针的”手动分配”技巧\"><a href=\"#指针的”手动分配”技巧\" class=\"headerlink\" title=\"指针的”手动分配”技巧\"></a>指针的”手动分配”技巧</h2><p>理解了指针的本质，我们甚至可以手动指定变量的存储区域。比如给结构体”分配”栈上的缓冲区：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">a</span>&#123;</span>&#125;;  <span class=\"comment\">// 空结构体（大小为0，但可以作为指针类型）</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">char</span> <span class=\"type\">const</span> *argv[])</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">char</span> buffer[<span class=\"number\">128</span>];  <span class=\"comment\">// 栈上的128字节缓冲区</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">a</span>* <span class=\"title\">sa</span> =</span> (<span class=\"keyword\">struct</span> a*)buffer;  <span class=\"comment\">// 让结构体指针指向缓冲区</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// 之后操作sa，就相当于操作buffer中的内存</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这种技巧在嵌入式开发或需要精确控制内存的场景中很常用。</p>\n<h2 id=\"总结：指针的核心是”瞎搞”的自由\"><a href=\"#总结：指针的核心是”瞎搞”的自由\" class=\"headerlink\" title=\"总结：指针的核心是”瞎搞”的自由\"></a>总结：指针的核心是”瞎搞”的自由</h2><p>C语言指针的魅力，在于它打破了很多”规则”：</p>\n<ul>\n<li>类型不限制存储的地址，只影响解读方式</li>\n<li>任何指针都能指向任何地址（函数、变量、数组…）</li>\n<li>可以手动控制内存的读写范围和方式</li>\n</ul>\n<p>当然，这种自由也伴随着风险，但是不得不说这玩意儿确实很好玩。</p>\n"},{"title":"Makefile 入门：从基础到实用技巧","date":"2022-04-30T01:59:14.000Z","_content":"# Makefile 入门：从基础到实用技巧\n\n## 一、为什么需要Makefile？\n\n简单说，Makefile是「编译规则说明书」。一个工程可能有几十上百个源文件，按功能放在不同目录里。Makefile定义了：\n- 哪些文件先编译，哪些后编译\n- 哪些文件修改后需要重新编译\n- 甚至可以执行打包、备份等额外操作\n\n有了Makefile，只需敲一个`make`命令，整个工程就会自动编译，极大提高开发效率。\n\n\n## 二、先搞懂：编译和链接\n\n在讲Makefile之前，先明确两个基本概念：\n- **编译（compile）**：把源代码（.c/.cpp）变成中间目标文件（Unix下是.o，Windows下是.obj）。编译器只检查语法和函数/变量是否声明。\n- **链接（link）**：把一堆中间目标文件拼成可执行文件。链接器找函数的实现，找不到就会报错（比如VC里的Link 2001）。\n\n举个例子：`main.c`编译成`main.o`，`tool.c`编译成`tool.o`，最后链接成`app`可执行文件。\n\n\n## 三、Makefile 基本规则\n\nMakefile的核心是「依赖关系」和「执行命令」，格式如下：\n\n```makefile\n目标（target）... : 依赖（prerequisites）...\n    命令（command）\n    ...\n```\n\n- **目标（target）**：可以是可执行文件、中间目标文件（.o），甚至是一个动作（如clean）。\n- **依赖（prerequisites）**：生成目标需要的文件或其他目标。\n- **命令（command）**：生成目标的具体操作（必须以Tab键开头）。\n\n规则逻辑：如果「依赖文件」比「目标文件」新（或目标不存在），就执行命令生成目标。\n\n\n## 四、一个简单示例\n\n假设工程有8个.c文件和3个头文件，要编译成可执行文件`edit`。一个基础的Makefile如下：\n\n```makefile\n# 最终目标：edit（依赖所有.o文件）\nedit : main.o kbd.o command.o display.o insert.o search.o files.o utils.o\n    cc -o edit main.o kbd.o command.o display.o insert.o search.o files.o utils.o\n\n# 每个.o文件的依赖和编译命令\nmain.o : main.c defs.h\n    cc -c main.c\nkbd.o : kbd.c defs.h command.h\n    cc -c kbd.c\n# ... 其他.o文件类似 ...\n\n# 清理目标：删除编译产物\nclean :\n    rm edit main.o kbd.o command.o display.o insert.o search.o files.o utils.o\n```\n\n### 用法：\n- 敲`make`：自动编译所有需要更新的文件，生成`edit`。\n- 敲`make clean`：删除`edit`和所有.o文件，方便重新编译。\n\n\n## 五、简化Makefile的技巧\n\n上面的示例有很多重复代码（比如一堆.o文件名），可以用「变量」和「自动推导」简化。\n\n\n### 5.1 用变量减少重复\n\n把重复出现的内容定义成变量，比如所有.o文件：\n\n```makefile\n# 定义变量objects，包含所有.o文件\nobjects = main.o kbd.o command.o display.o insert.o search.o files.o utils.o\n\n# 使用变量$(objects)代替重复的文件名\nedit : $(objects)\n    cc -o edit $(objects)\n\n# 清理命令也用变量\nclean :\n    rm edit $(objects)\n```\n\n以后新增.o文件，只需改`objects`变量即可。\n\n\n### 5.2 自动推导（隐含规则）\n\nGNU make很智能：看到`.o`文件，会自动找对应的`.c`文件作为依赖，并且自动生成编译命令（`cc -c 源文件`）。\n\n简化后的Makefile：\n\n```makefile\nobjects = main.o kbd.o command.o display.o insert.o search.o files.o utils.o\n\nedit : $(objects)\n    cc -o edit $(objects)\n\n# 只需写.o依赖的头文件，编译命令不用写\nmain.o : defs.h\nkbd.o : defs.h command.h\ncommand.o : defs.h command.h\n# ... 其他.o文件的头文件依赖 ...\n\n# 声明clean是伪目标（避免和同名文件冲突）\n.PHONY : clean\nclean :\n    rm edit $(objects)\n```\n\n是不是简洁多了？\n\n\n## 六、实用技巧\n\n### 6.1 伪目标（.PHONY）\n\n像`clean`这种「动作型目标」，不是真实文件，最好用`.PHONY`声明，避免和目录中同名文件冲突：\n\n```makefile\n.PHONY : clean  # 声明clean是伪目标\nclean :\n    rm edit $(objects)\n```\n\n\n### 6.2 自动生成依赖\n\n大型工程中，手动写`.o`依赖的头文件很麻烦。可以用编译器的`-MM`参数自动生成依赖：\n\n```makefile\n# 自动生成每个.c的依赖文件（.d）\n%.d: %.c\n    @set -e; rm -f $@; \\\n     cc -MM $(CPPFLAGS) $< > $@.tmp; \\\n     sed 's,\\($*\\)\\.o[ :]*,\\1.o $@ : ,g' < $@.tmp > $@; \\\n     rm -f $@.tmp\n\n# 引入所有.d文件\nsources = main.c kbd.c command.c display.c insert.c search.c files.c utils.c\ninclude $(sources:.c=.d)\n```\n\n这样头文件修改后，Makefile会自动识别需要重新编译的文件。\n\n\n### 6.3 嵌套执行make\n\n大型工程可以按模块分目录，每个目录放一个Makefile，总控Makefile调用子目录的Makefile：\n\n```makefile\n# 编译子目录subdir\nsubsystem:\n    cd subdir && $(MAKE)  # 等价于 $(MAKE) -C subdir\n```\n\n\n## 七、常用函数\n\nMakefile有一些实用函数，帮你处理字符串、文件名等：\n\n- **字符串替换**：`$(subst 旧字符串,新字符串,原字符串)`  \n  例：`$(subst .o,.c,main.o)` → 结果是`main.c`\n\n- **取目录**：`$(dir 文件名)`  \n  例：`$(dir src/main.c)` → 结果是`src/`\n\n- **过滤文件**：`$(filter 模式,文件列表)`  \n  例：`$(filter %.c,main.c tool.o test.c)` → 结果是`main.c test.c`\n\n","source":"_posts/2022-04-30-Makefile-入门：从基础到实用技巧.md","raw":"---\ntitle: Makefile 入门：从基础到实用技巧\ndate: 2022-04-30 9:59:14\ntags:\n---\n# Makefile 入门：从基础到实用技巧\n\n## 一、为什么需要Makefile？\n\n简单说，Makefile是「编译规则说明书」。一个工程可能有几十上百个源文件，按功能放在不同目录里。Makefile定义了：\n- 哪些文件先编译，哪些后编译\n- 哪些文件修改后需要重新编译\n- 甚至可以执行打包、备份等额外操作\n\n有了Makefile，只需敲一个`make`命令，整个工程就会自动编译，极大提高开发效率。\n\n\n## 二、先搞懂：编译和链接\n\n在讲Makefile之前，先明确两个基本概念：\n- **编译（compile）**：把源代码（.c/.cpp）变成中间目标文件（Unix下是.o，Windows下是.obj）。编译器只检查语法和函数/变量是否声明。\n- **链接（link）**：把一堆中间目标文件拼成可执行文件。链接器找函数的实现，找不到就会报错（比如VC里的Link 2001）。\n\n举个例子：`main.c`编译成`main.o`，`tool.c`编译成`tool.o`，最后链接成`app`可执行文件。\n\n\n## 三、Makefile 基本规则\n\nMakefile的核心是「依赖关系」和「执行命令」，格式如下：\n\n```makefile\n目标（target）... : 依赖（prerequisites）...\n    命令（command）\n    ...\n```\n\n- **目标（target）**：可以是可执行文件、中间目标文件（.o），甚至是一个动作（如clean）。\n- **依赖（prerequisites）**：生成目标需要的文件或其他目标。\n- **命令（command）**：生成目标的具体操作（必须以Tab键开头）。\n\n规则逻辑：如果「依赖文件」比「目标文件」新（或目标不存在），就执行命令生成目标。\n\n\n## 四、一个简单示例\n\n假设工程有8个.c文件和3个头文件，要编译成可执行文件`edit`。一个基础的Makefile如下：\n\n```makefile\n# 最终目标：edit（依赖所有.o文件）\nedit : main.o kbd.o command.o display.o insert.o search.o files.o utils.o\n    cc -o edit main.o kbd.o command.o display.o insert.o search.o files.o utils.o\n\n# 每个.o文件的依赖和编译命令\nmain.o : main.c defs.h\n    cc -c main.c\nkbd.o : kbd.c defs.h command.h\n    cc -c kbd.c\n# ... 其他.o文件类似 ...\n\n# 清理目标：删除编译产物\nclean :\n    rm edit main.o kbd.o command.o display.o insert.o search.o files.o utils.o\n```\n\n### 用法：\n- 敲`make`：自动编译所有需要更新的文件，生成`edit`。\n- 敲`make clean`：删除`edit`和所有.o文件，方便重新编译。\n\n\n## 五、简化Makefile的技巧\n\n上面的示例有很多重复代码（比如一堆.o文件名），可以用「变量」和「自动推导」简化。\n\n\n### 5.1 用变量减少重复\n\n把重复出现的内容定义成变量，比如所有.o文件：\n\n```makefile\n# 定义变量objects，包含所有.o文件\nobjects = main.o kbd.o command.o display.o insert.o search.o files.o utils.o\n\n# 使用变量$(objects)代替重复的文件名\nedit : $(objects)\n    cc -o edit $(objects)\n\n# 清理命令也用变量\nclean :\n    rm edit $(objects)\n```\n\n以后新增.o文件，只需改`objects`变量即可。\n\n\n### 5.2 自动推导（隐含规则）\n\nGNU make很智能：看到`.o`文件，会自动找对应的`.c`文件作为依赖，并且自动生成编译命令（`cc -c 源文件`）。\n\n简化后的Makefile：\n\n```makefile\nobjects = main.o kbd.o command.o display.o insert.o search.o files.o utils.o\n\nedit : $(objects)\n    cc -o edit $(objects)\n\n# 只需写.o依赖的头文件，编译命令不用写\nmain.o : defs.h\nkbd.o : defs.h command.h\ncommand.o : defs.h command.h\n# ... 其他.o文件的头文件依赖 ...\n\n# 声明clean是伪目标（避免和同名文件冲突）\n.PHONY : clean\nclean :\n    rm edit $(objects)\n```\n\n是不是简洁多了？\n\n\n## 六、实用技巧\n\n### 6.1 伪目标（.PHONY）\n\n像`clean`这种「动作型目标」，不是真实文件，最好用`.PHONY`声明，避免和目录中同名文件冲突：\n\n```makefile\n.PHONY : clean  # 声明clean是伪目标\nclean :\n    rm edit $(objects)\n```\n\n\n### 6.2 自动生成依赖\n\n大型工程中，手动写`.o`依赖的头文件很麻烦。可以用编译器的`-MM`参数自动生成依赖：\n\n```makefile\n# 自动生成每个.c的依赖文件（.d）\n%.d: %.c\n    @set -e; rm -f $@; \\\n     cc -MM $(CPPFLAGS) $< > $@.tmp; \\\n     sed 's,\\($*\\)\\.o[ :]*,\\1.o $@ : ,g' < $@.tmp > $@; \\\n     rm -f $@.tmp\n\n# 引入所有.d文件\nsources = main.c kbd.c command.c display.c insert.c search.c files.c utils.c\ninclude $(sources:.c=.d)\n```\n\n这样头文件修改后，Makefile会自动识别需要重新编译的文件。\n\n\n### 6.3 嵌套执行make\n\n大型工程可以按模块分目录，每个目录放一个Makefile，总控Makefile调用子目录的Makefile：\n\n```makefile\n# 编译子目录subdir\nsubsystem:\n    cd subdir && $(MAKE)  # 等价于 $(MAKE) -C subdir\n```\n\n\n## 七、常用函数\n\nMakefile有一些实用函数，帮你处理字符串、文件名等：\n\n- **字符串替换**：`$(subst 旧字符串,新字符串,原字符串)`  \n  例：`$(subst .o,.c,main.o)` → 结果是`main.c`\n\n- **取目录**：`$(dir 文件名)`  \n  例：`$(dir src/main.c)` → 结果是`src/`\n\n- **过滤文件**：`$(filter 模式,文件列表)`  \n  例：`$(filter %.c,main.c tool.o test.c)` → 结果是`main.c test.c`\n\n","slug":"Makefile-入门：从基础到实用技巧","published":1,"updated":"2025-08-01T10:22:18.488Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cmdsod87w0000nsli61ix1u1u","content":"<h1 id=\"Makefile-入门：从基础到实用技巧\"><a href=\"#Makefile-入门：从基础到实用技巧\" class=\"headerlink\" title=\"Makefile 入门：从基础到实用技巧\"></a>Makefile 入门：从基础到实用技巧</h1><h2 id=\"一、为什么需要Makefile？\"><a href=\"#一、为什么需要Makefile？\" class=\"headerlink\" title=\"一、为什么需要Makefile？\"></a>一、为什么需要Makefile？</h2><p>简单说，Makefile是「编译规则说明书」。一个工程可能有几十上百个源文件，按功能放在不同目录里。Makefile定义了：</p>\n<ul>\n<li>哪些文件先编译，哪些后编译</li>\n<li>哪些文件修改后需要重新编译</li>\n<li>甚至可以执行打包、备份等额外操作</li>\n</ul>\n<p>有了Makefile，只需敲一个<code>make</code>命令，整个工程就会自动编译，极大提高开发效率。</p>\n<h2 id=\"二、先搞懂：编译和链接\"><a href=\"#二、先搞懂：编译和链接\" class=\"headerlink\" title=\"二、先搞懂：编译和链接\"></a>二、先搞懂：编译和链接</h2><p>在讲Makefile之前，先明确两个基本概念：</p>\n<ul>\n<li><strong>编译（compile）</strong>：把源代码（.c&#x2F;.cpp）变成中间目标文件（Unix下是.o，Windows下是.obj）。编译器只检查语法和函数&#x2F;变量是否声明。</li>\n<li><strong>链接（link）</strong>：把一堆中间目标文件拼成可执行文件。链接器找函数的实现，找不到就会报错（比如VC里的Link 2001）。</li>\n</ul>\n<p>举个例子：<code>main.c</code>编译成<code>main.o</code>，<code>tool.c</code>编译成<code>tool.o</code>，最后链接成<code>app</code>可执行文件。</p>\n<h2 id=\"三、Makefile-基本规则\"><a href=\"#三、Makefile-基本规则\" class=\"headerlink\" title=\"三、Makefile 基本规则\"></a>三、Makefile 基本规则</h2><p>Makefile的核心是「依赖关系」和「执行命令」，格式如下：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">目标（target）... : 依赖（prerequisites）...</span><br><span class=\"line\">    命令（command）</span><br><span class=\"line\">    ...</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>目标（target）</strong>：可以是可执行文件、中间目标文件（.o），甚至是一个动作（如clean）。</li>\n<li><strong>依赖（prerequisites）</strong>：生成目标需要的文件或其他目标。</li>\n<li><strong>命令（command）</strong>：生成目标的具体操作（必须以Tab键开头）。</li>\n</ul>\n<p>规则逻辑：如果「依赖文件」比「目标文件」新（或目标不存在），就执行命令生成目标。</p>\n<h2 id=\"四、一个简单示例\"><a href=\"#四、一个简单示例\" class=\"headerlink\" title=\"四、一个简单示例\"></a>四、一个简单示例</h2><p>假设工程有8个.c文件和3个头文件，要编译成可执行文件<code>edit</code>。一个基础的Makefile如下：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 最终目标：edit（依赖所有.o文件）</span></span><br><span class=\"line\">edit : main.o kbd.o command.o display.o insert.o search.o files.o utils.o</span><br><span class=\"line\">    cc -o edit main.o kbd.o command.o display.o insert.o search.o files.o utils.o</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 每个.o文件的依赖和编译命令</span></span><br><span class=\"line\">main.o : main.c defs.h</span><br><span class=\"line\">    cc -c main.c</span><br><span class=\"line\">kbd.o : kbd.c defs.h command.h</span><br><span class=\"line\">    cc -c kbd.c</span><br><span class=\"line\"><span class=\"comment\"># ... 其他.o文件类似 ...</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 清理目标：删除编译产物</span></span><br><span class=\"line\">clean :</span><br><span class=\"line\">    rm edit main.o kbd.o command.o display.o insert.o search.o files.o utils.o</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"用法：\"><a href=\"#用法：\" class=\"headerlink\" title=\"用法：\"></a>用法：</h3><ul>\n<li>敲<code>make</code>：自动编译所有需要更新的文件，生成<code>edit</code>。</li>\n<li>敲<code>make clean</code>：删除<code>edit</code>和所有.o文件，方便重新编译。</li>\n</ul>\n<h2 id=\"五、简化Makefile的技巧\"><a href=\"#五、简化Makefile的技巧\" class=\"headerlink\" title=\"五、简化Makefile的技巧\"></a>五、简化Makefile的技巧</h2><p>上面的示例有很多重复代码（比如一堆.o文件名），可以用「变量」和「自动推导」简化。</p>\n<h3 id=\"5-1-用变量减少重复\"><a href=\"#5-1-用变量减少重复\" class=\"headerlink\" title=\"5.1 用变量减少重复\"></a>5.1 用变量减少重复</h3><p>把重复出现的内容定义成变量，比如所有.o文件：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 定义变量objects，包含所有.o文件</span></span><br><span class=\"line\">objects = main.o kbd.o command.o display.o insert.o search.o files.o utils.o</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 使用变量$(objects)代替重复的文件名</span></span><br><span class=\"line\">edit : <span class=\"variable\">$(objects)</span></span><br><span class=\"line\">    cc -o edit <span class=\"variable\">$(objects)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 清理命令也用变量</span></span><br><span class=\"line\">clean :</span><br><span class=\"line\">    rm edit <span class=\"variable\">$(objects)</span></span><br></pre></td></tr></table></figure>\n\n<p>以后新增.o文件，只需改<code>objects</code>变量即可。</p>\n<h3 id=\"5-2-自动推导（隐含规则）\"><a href=\"#5-2-自动推导（隐含规则）\" class=\"headerlink\" title=\"5.2 自动推导（隐含规则）\"></a>5.2 自动推导（隐含规则）</h3><p>GNU make很智能：看到<code>.o</code>文件，会自动找对应的<code>.c</code>文件作为依赖，并且自动生成编译命令（<code>cc -c 源文件</code>）。</p>\n<p>简化后的Makefile：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">objects = main.o kbd.o command.o display.o insert.o search.o files.o utils.o</span><br><span class=\"line\"></span><br><span class=\"line\">edit : <span class=\"variable\">$(objects)</span></span><br><span class=\"line\">    cc -o edit <span class=\"variable\">$(objects)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 只需写.o依赖的头文件，编译命令不用写</span></span><br><span class=\"line\">main.o : defs.h</span><br><span class=\"line\">kbd.o : defs.h command.h</span><br><span class=\"line\">command.o : defs.h command.h</span><br><span class=\"line\"><span class=\"comment\"># ... 其他.o文件的头文件依赖 ...</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 声明clean是伪目标（避免和同名文件冲突）</span></span><br><span class=\"line\">.PHONY : clean</span><br><span class=\"line\">clean :</span><br><span class=\"line\">    rm edit <span class=\"variable\">$(objects)</span></span><br></pre></td></tr></table></figure>\n\n<p>是不是简洁多了？</p>\n<h2 id=\"六、实用技巧\"><a href=\"#六、实用技巧\" class=\"headerlink\" title=\"六、实用技巧\"></a>六、实用技巧</h2><h3 id=\"6-1-伪目标（-PHONY）\"><a href=\"#6-1-伪目标（-PHONY）\" class=\"headerlink\" title=\"6.1 伪目标（.PHONY）\"></a>6.1 伪目标（.PHONY）</h3><p>像<code>clean</code>这种「动作型目标」，不是真实文件，最好用<code>.PHONY</code>声明，避免和目录中同名文件冲突：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.PHONY : clean  <span class=\"comment\"># 声明clean是伪目标</span></span><br><span class=\"line\">clean :</span><br><span class=\"line\">    rm edit <span class=\"variable\">$(objects)</span></span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"6-2-自动生成依赖\"><a href=\"#6-2-自动生成依赖\" class=\"headerlink\" title=\"6.2 自动生成依赖\"></a>6.2 自动生成依赖</h3><p>大型工程中，手动写<code>.o</code>依赖的头文件很麻烦。可以用编译器的<code>-MM</code>参数自动生成依赖：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 自动生成每个.c的依赖文件（.d）</span></span><br><span class=\"line\"><span class=\"section\">%.d: %.c</span></span><br><span class=\"line\">    @set -e; rm -f <span class=\"variable\">$@</span>; \\</span><br><span class=\"line\">     cc -MM <span class=\"variable\">$(CPPFLAGS)</span> <span class=\"variable\">$&lt;</span> &gt; <span class=\"variable\">$@</span>.tmp; \\</span><br><span class=\"line\">     sed &#x27;s,\\(<span class=\"variable\">$*</span>\\)\\.o[ :]*,\\1.o <span class=\"variable\">$@</span> : ,g&#x27; &lt; <span class=\"variable\">$@</span>.tmp &gt; <span class=\"variable\">$@</span>; \\</span><br><span class=\"line\">     rm -f <span class=\"variable\">$@</span>.tmp</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 引入所有.d文件</span></span><br><span class=\"line\">sources = main.c kbd.c command.c display.c insert.c search.c files.c utils.c</span><br><span class=\"line\"><span class=\"keyword\">include</span> $(sources:.c=.d)</span><br></pre></td></tr></table></figure>\n\n<p>这样头文件修改后，Makefile会自动识别需要重新编译的文件。</p>\n<h3 id=\"6-3-嵌套执行make\"><a href=\"#6-3-嵌套执行make\" class=\"headerlink\" title=\"6.3 嵌套执行make\"></a>6.3 嵌套执行make</h3><p>大型工程可以按模块分目录，每个目录放一个Makefile，总控Makefile调用子目录的Makefile：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 编译子目录subdir</span></span><br><span class=\"line\"><span class=\"section\">subsystem:</span></span><br><span class=\"line\">    cd subdir &amp;&amp; <span class=\"variable\">$(MAKE)</span>  <span class=\"comment\"># 等价于 $(MAKE) -C subdir</span></span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"七、常用函数\"><a href=\"#七、常用函数\" class=\"headerlink\" title=\"七、常用函数\"></a>七、常用函数</h2><p>Makefile有一些实用函数，帮你处理字符串、文件名等：</p>\n<ul>\n<li><p><strong>字符串替换</strong>：<code>$(subst 旧字符串,新字符串,原字符串)</code><br>例：<code>$(subst .o,.c,main.o)</code> → 结果是<code>main.c</code></p>\n</li>\n<li><p><strong>取目录</strong>：<code>$(dir 文件名)</code><br>例：<code>$(dir src/main.c)</code> → 结果是<code>src/</code></p>\n</li>\n<li><p><strong>过滤文件</strong>：<code>$(filter 模式,文件列表)</code><br>例：<code>$(filter %.c,main.c tool.o test.c)</code> → 结果是<code>main.c test.c</code></p>\n</li>\n</ul>\n","site":{"data":{}},"length":1139,"excerpt":"","more":"<h1 id=\"Makefile-入门：从基础到实用技巧\"><a href=\"#Makefile-入门：从基础到实用技巧\" class=\"headerlink\" title=\"Makefile 入门：从基础到实用技巧\"></a>Makefile 入门：从基础到实用技巧</h1><h2 id=\"一、为什么需要Makefile？\"><a href=\"#一、为什么需要Makefile？\" class=\"headerlink\" title=\"一、为什么需要Makefile？\"></a>一、为什么需要Makefile？</h2><p>简单说，Makefile是「编译规则说明书」。一个工程可能有几十上百个源文件，按功能放在不同目录里。Makefile定义了：</p>\n<ul>\n<li>哪些文件先编译，哪些后编译</li>\n<li>哪些文件修改后需要重新编译</li>\n<li>甚至可以执行打包、备份等额外操作</li>\n</ul>\n<p>有了Makefile，只需敲一个<code>make</code>命令，整个工程就会自动编译，极大提高开发效率。</p>\n<h2 id=\"二、先搞懂：编译和链接\"><a href=\"#二、先搞懂：编译和链接\" class=\"headerlink\" title=\"二、先搞懂：编译和链接\"></a>二、先搞懂：编译和链接</h2><p>在讲Makefile之前，先明确两个基本概念：</p>\n<ul>\n<li><strong>编译（compile）</strong>：把源代码（.c&#x2F;.cpp）变成中间目标文件（Unix下是.o，Windows下是.obj）。编译器只检查语法和函数&#x2F;变量是否声明。</li>\n<li><strong>链接（link）</strong>：把一堆中间目标文件拼成可执行文件。链接器找函数的实现，找不到就会报错（比如VC里的Link 2001）。</li>\n</ul>\n<p>举个例子：<code>main.c</code>编译成<code>main.o</code>，<code>tool.c</code>编译成<code>tool.o</code>，最后链接成<code>app</code>可执行文件。</p>\n<h2 id=\"三、Makefile-基本规则\"><a href=\"#三、Makefile-基本规则\" class=\"headerlink\" title=\"三、Makefile 基本规则\"></a>三、Makefile 基本规则</h2><p>Makefile的核心是「依赖关系」和「执行命令」，格式如下：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">目标（target）... : 依赖（prerequisites）...</span><br><span class=\"line\">    命令（command）</span><br><span class=\"line\">    ...</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>目标（target）</strong>：可以是可执行文件、中间目标文件（.o），甚至是一个动作（如clean）。</li>\n<li><strong>依赖（prerequisites）</strong>：生成目标需要的文件或其他目标。</li>\n<li><strong>命令（command）</strong>：生成目标的具体操作（必须以Tab键开头）。</li>\n</ul>\n<p>规则逻辑：如果「依赖文件」比「目标文件」新（或目标不存在），就执行命令生成目标。</p>\n<h2 id=\"四、一个简单示例\"><a href=\"#四、一个简单示例\" class=\"headerlink\" title=\"四、一个简单示例\"></a>四、一个简单示例</h2><p>假设工程有8个.c文件和3个头文件，要编译成可执行文件<code>edit</code>。一个基础的Makefile如下：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 最终目标：edit（依赖所有.o文件）</span></span><br><span class=\"line\">edit : main.o kbd.o command.o display.o insert.o search.o files.o utils.o</span><br><span class=\"line\">    cc -o edit main.o kbd.o command.o display.o insert.o search.o files.o utils.o</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 每个.o文件的依赖和编译命令</span></span><br><span class=\"line\">main.o : main.c defs.h</span><br><span class=\"line\">    cc -c main.c</span><br><span class=\"line\">kbd.o : kbd.c defs.h command.h</span><br><span class=\"line\">    cc -c kbd.c</span><br><span class=\"line\"><span class=\"comment\"># ... 其他.o文件类似 ...</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 清理目标：删除编译产物</span></span><br><span class=\"line\">clean :</span><br><span class=\"line\">    rm edit main.o kbd.o command.o display.o insert.o search.o files.o utils.o</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"用法：\"><a href=\"#用法：\" class=\"headerlink\" title=\"用法：\"></a>用法：</h3><ul>\n<li>敲<code>make</code>：自动编译所有需要更新的文件，生成<code>edit</code>。</li>\n<li>敲<code>make clean</code>：删除<code>edit</code>和所有.o文件，方便重新编译。</li>\n</ul>\n<h2 id=\"五、简化Makefile的技巧\"><a href=\"#五、简化Makefile的技巧\" class=\"headerlink\" title=\"五、简化Makefile的技巧\"></a>五、简化Makefile的技巧</h2><p>上面的示例有很多重复代码（比如一堆.o文件名），可以用「变量」和「自动推导」简化。</p>\n<h3 id=\"5-1-用变量减少重复\"><a href=\"#5-1-用变量减少重复\" class=\"headerlink\" title=\"5.1 用变量减少重复\"></a>5.1 用变量减少重复</h3><p>把重复出现的内容定义成变量，比如所有.o文件：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 定义变量objects，包含所有.o文件</span></span><br><span class=\"line\">objects = main.o kbd.o command.o display.o insert.o search.o files.o utils.o</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 使用变量$(objects)代替重复的文件名</span></span><br><span class=\"line\">edit : <span class=\"variable\">$(objects)</span></span><br><span class=\"line\">    cc -o edit <span class=\"variable\">$(objects)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 清理命令也用变量</span></span><br><span class=\"line\">clean :</span><br><span class=\"line\">    rm edit <span class=\"variable\">$(objects)</span></span><br></pre></td></tr></table></figure>\n\n<p>以后新增.o文件，只需改<code>objects</code>变量即可。</p>\n<h3 id=\"5-2-自动推导（隐含规则）\"><a href=\"#5-2-自动推导（隐含规则）\" class=\"headerlink\" title=\"5.2 自动推导（隐含规则）\"></a>5.2 自动推导（隐含规则）</h3><p>GNU make很智能：看到<code>.o</code>文件，会自动找对应的<code>.c</code>文件作为依赖，并且自动生成编译命令（<code>cc -c 源文件</code>）。</p>\n<p>简化后的Makefile：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">objects = main.o kbd.o command.o display.o insert.o search.o files.o utils.o</span><br><span class=\"line\"></span><br><span class=\"line\">edit : <span class=\"variable\">$(objects)</span></span><br><span class=\"line\">    cc -o edit <span class=\"variable\">$(objects)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 只需写.o依赖的头文件，编译命令不用写</span></span><br><span class=\"line\">main.o : defs.h</span><br><span class=\"line\">kbd.o : defs.h command.h</span><br><span class=\"line\">command.o : defs.h command.h</span><br><span class=\"line\"><span class=\"comment\"># ... 其他.o文件的头文件依赖 ...</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 声明clean是伪目标（避免和同名文件冲突）</span></span><br><span class=\"line\">.PHONY : clean</span><br><span class=\"line\">clean :</span><br><span class=\"line\">    rm edit <span class=\"variable\">$(objects)</span></span><br></pre></td></tr></table></figure>\n\n<p>是不是简洁多了？</p>\n<h2 id=\"六、实用技巧\"><a href=\"#六、实用技巧\" class=\"headerlink\" title=\"六、实用技巧\"></a>六、实用技巧</h2><h3 id=\"6-1-伪目标（-PHONY）\"><a href=\"#6-1-伪目标（-PHONY）\" class=\"headerlink\" title=\"6.1 伪目标（.PHONY）\"></a>6.1 伪目标（.PHONY）</h3><p>像<code>clean</code>这种「动作型目标」，不是真实文件，最好用<code>.PHONY</code>声明，避免和目录中同名文件冲突：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.PHONY : clean  <span class=\"comment\"># 声明clean是伪目标</span></span><br><span class=\"line\">clean :</span><br><span class=\"line\">    rm edit <span class=\"variable\">$(objects)</span></span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"6-2-自动生成依赖\"><a href=\"#6-2-自动生成依赖\" class=\"headerlink\" title=\"6.2 自动生成依赖\"></a>6.2 自动生成依赖</h3><p>大型工程中，手动写<code>.o</code>依赖的头文件很麻烦。可以用编译器的<code>-MM</code>参数自动生成依赖：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 自动生成每个.c的依赖文件（.d）</span></span><br><span class=\"line\"><span class=\"section\">%.d: %.c</span></span><br><span class=\"line\">    @set -e; rm -f <span class=\"variable\">$@</span>; \\</span><br><span class=\"line\">     cc -MM <span class=\"variable\">$(CPPFLAGS)</span> <span class=\"variable\">$&lt;</span> &gt; <span class=\"variable\">$@</span>.tmp; \\</span><br><span class=\"line\">     sed &#x27;s,\\(<span class=\"variable\">$*</span>\\)\\.o[ :]*,\\1.o <span class=\"variable\">$@</span> : ,g&#x27; &lt; <span class=\"variable\">$@</span>.tmp &gt; <span class=\"variable\">$@</span>; \\</span><br><span class=\"line\">     rm -f <span class=\"variable\">$@</span>.tmp</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 引入所有.d文件</span></span><br><span class=\"line\">sources = main.c kbd.c command.c display.c insert.c search.c files.c utils.c</span><br><span class=\"line\"><span class=\"keyword\">include</span> $(sources:.c=.d)</span><br></pre></td></tr></table></figure>\n\n<p>这样头文件修改后，Makefile会自动识别需要重新编译的文件。</p>\n<h3 id=\"6-3-嵌套执行make\"><a href=\"#6-3-嵌套执行make\" class=\"headerlink\" title=\"6.3 嵌套执行make\"></a>6.3 嵌套执行make</h3><p>大型工程可以按模块分目录，每个目录放一个Makefile，总控Makefile调用子目录的Makefile：</p>\n<figure class=\"highlight makefile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 编译子目录subdir</span></span><br><span class=\"line\"><span class=\"section\">subsystem:</span></span><br><span class=\"line\">    cd subdir &amp;&amp; <span class=\"variable\">$(MAKE)</span>  <span class=\"comment\"># 等价于 $(MAKE) -C subdir</span></span><br></pre></td></tr></table></figure>\n\n\n<h2 id=\"七、常用函数\"><a href=\"#七、常用函数\" class=\"headerlink\" title=\"七、常用函数\"></a>七、常用函数</h2><p>Makefile有一些实用函数，帮你处理字符串、文件名等：</p>\n<ul>\n<li><p><strong>字符串替换</strong>：<code>$(subst 旧字符串,新字符串,原字符串)</code><br>例：<code>$(subst .o,.c,main.o)</code> → 结果是<code>main.c</code></p>\n</li>\n<li><p><strong>取目录</strong>：<code>$(dir 文件名)</code><br>例：<code>$(dir src/main.c)</code> → 结果是<code>src/</code></p>\n</li>\n<li><p><strong>过滤文件</strong>：<code>$(filter 模式,文件列表)</code><br>例：<code>$(filter %.c,main.c tool.o test.c)</code> → 结果是<code>main.c test.c</code></p>\n</li>\n</ul>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[],"Tag":[]}}